(import string)
(import lua/math math)
(import lua/debug debug)

(defun remap-message (mappings msg)
  "Remap MSG using the line MAPPINGS."
  (case (list (string/match msg "^(.-):(%d+)(.*)$"))
    [(?file ?line ?extra)
      (with (mapping (.> mappings file))
        (if mapping
          (with (range (.> mapping (string->number line)))
            (if range
              (.. range " (" file ":" line ")" extra)
              msg))
          msg))]
    [_ msg]))

(defun remap-traceback (mappings msg)
  "Remap the traceback MSG using the line MAPPINGS."
  (-> msg
    (string/gsub <> "^([^\n:]-:%d+:)" (cut remap-message mappings <>))
    (string/gsub <> "\t([^\n:]-:%d+:)" (lambda (msg) (.. "\t" (remap-message mappings msg))))
    (string/gsub <> "<([^\n:]-:%d+)>" (lambda (msg) (.. "<" (remap-message mappings msg) ">")))))

(defun generate-mappings (lines)
  "Generate mappings from the LINES generated by the writer."
  (with (out-lines (empty-struct))
    (for-pairs (line ranges) lines
      ;; For each line in the line mappings we attempt to find the "dominant"
      ;; range that this block exists for. We do this by listing all files and lines
      ;; this exists for and finding the most common file.
      ;; This could probably be improved by narrowing down the range too.
      (with (range-lists (empty-struct))
        (for-pairs (pos) ranges
          (let* [(file (.> pos :name))
                 (range-list (.> range-lists :file))]
            (unless range-list
              (set! range-list (struct
                                 :n 0
                                 :min math/huge
                                 :max (- 0 math/huge)))
              (.<! range-lists file range-list))

            (for i (.> pos :start :line) (.> pos :finish :line) 1
              (unless (.> range-list i)
                (.<! range-list :n (succ (.> range-list :n)))
                (.<! range-list i true)
                (when (< i (.> range-list :min)) (.<! range-list :min i))
                (when (> i (.> range-list :max)) (.<! range-list :max i))))))

        (let* [(best-name nil)
               (best-lines nil)
               (best-count 0)]
          (for-pairs (name lines) range-lists
            (when (> (.> lines :n) best-count)
              (set! best-name name)
              (set! best-lines lines)
              (set! best-count (.> lines :n))))

          ;; We either emit a range of lines or a single line
          (.<! out-lines line (if (= (.> best-lines :min) (.> best-lines :max))
                                (string/format "%s:%d" best-name (.> best-lines :min))
                                (string/format "%s:%d-%d" best-name (.> best-lines :min) (.> best-lines :max)))))))
    out-lines))


(struct
  :remapMessage   remap-message
  :remapTraceback remap-traceback
  :generate       generate-mappings)
