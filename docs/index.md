---
title: Symbol index
---
# Symbol index

{:.sym-toc}
 - [$](#sym-symbols)
 - [a](#sym-a)
 - [b](#sym-b)
 - [c](#sym-c)
 - [d](#sym-d)
 - [e](#sym-e)
 - [f](#sym-f)
 - [g](#sym-g)
 - [h](#sym-h)
 - [i](#sym-i)
 - [k](#sym-k)
 - [l](#sym-l)
 - [m](#sym-m)
 - [n](#sym-n)
 - [o](#sym-o)
 - [p](#sym-p)
 - [q](#sym-q)
 - [r](#sym-r)
 - [s](#sym-s)
 - [t](#sym-t)
 - [u](#sym-u)
 - [v](#sym-v)
 - [w](#sym-w)
 - [x](#sym-x)
 - [y](#sym-y)

{:.sym-table}
|   | Symbol | Defined in |
| - | ------ | ---------- |
| <strong id="sym-symbols">$</strong> | |
| |[`$`](lib.core.string.md#-str "Macro defined at lib/core/string.lisp:122:2"): Perform interpolation (variable substitution) on the string `STR`.|[core/string](lib.core.string.md "Also exported from core/prelude, prelude")|
| |[`$complex`](lib.math.complex.md#-complex "Defined at lib/math/complex.lisp:16:2")|[math/complex](lib.math.complex.md)|
| |[`$continuation`](lib.control.prompt.md#-continuation "Defined at lib/control/prompt.lisp:13:2")|[control/prompt](lib.control.prompt.md)|
| |[`$graph`](lib.data.graph.md#-graph "Defined at lib/data/graph.lisp:9:2")|[data/graph](lib.data.graph.md)|
| |[`$matrix`](lib.math.matrix.md#-matrix "Defined at lib/math/matrix.lisp:6:2")|[math/matrix](lib.math.matrix.md)|
| |[`$rational`](lib.math.rational.md#-rational "Defined at lib/math/rational.lisp:7:2")|[math/rational](lib.math.rational.md "Also exported from prelude")|
| |[`$set`](lib.data.set.md#-set "Defined at lib/data/set.lisp:6:2")|[data/set](lib.data.set.md)|
| |[`$vector`](lib.math.vector.md#-vector "Defined at lib/math/vector.lisp:7:2")|[math/vector](lib.math.vector.md)|
| |[`$vertex`](lib.data.graph.md#-vertex "Defined at lib/data/graph.lisp:17:2")|[data/graph](lib.data.graph.md)|
| |[`*`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:10:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`*standard-error*`](lib.core.prelude.md#-standard-error- "Defined at lib/core/prelude.lisp:26:1"): The standard error stream.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`*standard-input*`](lib.core.prelude.md#-standard-input- "Defined at lib/core/prelude.lisp:30:1"): The standard input stream.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`*standard-output*`](lib.core.prelude.md#-standard-output- "Defined at lib/core/prelude.lisp:22:1"): The standard output stream.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`+`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:8:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`-`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:9:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`->`](lib.data.function.md#-x-funcs "Macro defined at lib/data/function.lisp:59:2"): Chain a series of method calls together.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`->float`](lib.math.rational.md#-float-y "Defined at lib/math/rational.lisp:57:2"): Convert the rational number `Y` to a floating-point number.|[math/rational](lib.math.rational.md "Also exported from prelude")|
| |[`->polar`](lib.math.complex.md#-polar-z "Defined at lib/math/complex.lisp:103:2"): Get the `magnitude` and `angle` of complex number `Z`.|[math/complex](lib.math.complex.md)|
| |[`->rat`](lib.math.rational.md#-rat-y "Defined at lib/math/rational.lisp:44:2"): Convert the floating-point number `Y` to a rational number.|[math/rational](lib.math.rational.md "Also exported from prelude")|
| |[`-and`](lib.core.base.md#-and-a-b "Defined at lib/core/base.lisp:344:2"): Return the logical conjunction of values `A` and `B`.|[core/base](lib.core.base.md)|
| |[`-or`](lib.core.base.md#-or-a-b "Defined at lib/core/base.lisp:336:2"): Return the logical disjunction of values `A` and `B`.|[core/base](lib.core.base.md)|
| |[`..`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:14:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`.<!`](lib.core.table.md#-x-keys-value "Macro defined at lib/core/table.lisp:54:2"): Set the value at `KEYS` in the structure `X` to `VALUE`.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`.>`](lib.core.table.md#-x-keys "Macro defined at lib/core/table.lisp:48:2"): Index the structure `X` with the sequence of accesses given by `KEYS`.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`/`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:11:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`/=`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:2:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`/=`](lib.control.comparison.md#-a-b-rest "Macro defined at lib/control/comparison.lisp:54:2"): Check whether `A` is not equal to `B`, `B` is not equal to the first element in `REST`, etc.|[control/comparison](lib.control.comparison.md)|
| |[`<`](lib.control.comparison.md#-a-b-rest "Macro defined at lib/control/comparison.lisp:72:2"): Check whether `A` is smaller than `B`, `B` is smaller than the first element in `REST`, and so on for all subsequent arguments.|[control/comparison](lib.control.comparison.md)|
| |[`<`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:3:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`<=`](lib.control.comparison.md#-a-b-rest "Macro defined at lib/control/comparison.lisp:100:2"): Check whether `A` is smaller or equal to `B`, `B` is smaller or equal to the first element in `REST`, and so on for all subsequent arguments.|[control/comparison](lib.control.comparison.md)|
| |[`<=`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:4:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`<=>`](lib.core.base.md#-p-q "Macro defined at lib/core/base.lisp:320:2"): Bidirectional implication.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`<>`](lib.data.lens.md#-lenses "Defined at lib/data/lens.lisp:138:2"): Compose, left-associatively, the list of lenses given by `LENSES`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`=`](lib.control.comparison.md#-a-b-rest "Macro defined at lib/control/comparison.lisp:37:2"): Check whether `A`, `B` and all items in `REST` are equal.|[control/comparison](lib.control.comparison.md)|
| |[`=`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:1:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`=:=`](lib.test.check.md#-f-g-x "Macro defined at lib/test/check.lisp:141:2"): Express that the functions `F` and `G` are equivalent at the point `X`.|[test/check](lib.test.check.md "Also exported from test")|
| |[`=>`](lib.core.base.md#-p-q "Macro defined at lib/core/base.lisp:310:2"): Logical implication.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`>`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:5:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`>`](lib.control.comparison.md#-a-b-rest "Macro defined at lib/control/comparison.lisp:86:2"): Check whether `A` is larger than `B`, `B` is larger than the first element in `REST`, and so on for all subsequent arguments.|[control/comparison](lib.control.comparison.md)|
| |[`>=`](lib.control.comparison.md#-a-b-rest "Macro defined at lib/control/comparison.lisp:114:2"): Check whether `A` is larger or equal to `B`, `B` is larger or equal to the first element in `REST`, and so on for all subsequent arguments.|[control/comparison](lib.control.comparison.md)|
| |[`>=`](lib.lua.basic.md#- "Native defined at lib/lua/basic.lisp:6:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`\\`](lib.core.list.md#-xs-ys "Defined at lib/core/list.lisp:269:2"): The difference between `XS` and `YS` (non-associative.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`^.`](lib.data.lens.md#-val-lens "Defined at lib/data/lens.lisp:149:2"): Use `LENS` to focus on a bit of `VAL`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`^=`](lib.data.lens.md#-val-lens-new "Defined at lib/data/lens.lisp:161:2"): Use `LENS` to replace a bit of `VAL` with `NEW`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`^~`](lib.data.lens.md#-val-lens-f "Defined at lib/data/lens.lisp:155:2"): Use `LENS` to apply the function `F` over a bit of `VAL`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`_ENV`](lib.lua.basic.md#-ENV "Native defined at lib/lua/basic.lisp:17:1")|[lua/basic](lib.lua.basic.md)|
| |[`_G`](lib.lua.basic.md#-G "Native defined at lib/lua/basic.lisp:16:1")|[lua/basic](lib.lua.basic.md)|
| <strong id="sym-a">a</strong> | |
| |[`abi`](lib.luajit.ffi.md#abi "Native defined at lib/luajit/ffi.lisp:9:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`abort-to-prompt`](lib.control.prompt.md#abort-to-prompt-tag-rest "Defined at lib/control/prompt.lisp:123:2"): Abort to the prompt `TAG`, giving `REST` as arguments to the handler.|[control/prompt](lib.control.prompt.md)|
| |[`abort/p`](lib.control.prompt.md#abort-p-tag-rest "Defined at lib/control/prompt.lisp:127:2"): Abort to the prompt `TAG`, giving `REST` as arguments to the handler.|[control/prompt](lib.control.prompt.md)|
| |[`abs`](lib.lua.math.md#abs "Native defined at lib/lua/math.lisp:1:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`absolute`](lib.math.bignum.md#absolute-a "Defined at lib/math/bignum.lisp:29:2"): Returns `A` if `A` is positive, otherwise inverts the sign and returns the positive version of `A`.|[math/bignum](lib.math.bignum.md)|
| |[`accumulate-with`](lib.core.list.md#accumulate-with-f-ac-z-xs "Defined at lib/core/list.lisp:619:2"): `A` composition of `reduce` and `map`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`accumulating`](lib.data.lens.md#accumulating-f-z-l "Defined at lib/data/lens.lisp:310:2"): Transform the lens `L` into a getter which folds the result using the function `F` and the zero element `Z`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`acos`](lib.lua.math.md#acos "Native defined at lib/lua/math.lisp:2:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`active-module`](lib.compiler.resolve.md#active-module "Native defined at lib/compiler/resolve.lisp:7:1"): Get the module of the node currently being resolved.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`active-node`](lib.compiler.resolve.md#active-node "Native defined at lib/compiler/resolve.lisp:1:1"): Get the node currently being resolved.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`active-scope`](lib.compiler.resolve.md#active-scope "Native defined at lib/compiler/resolve.lisp:4:1"): Get the scope of the node currently being resolved.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`add`](lib.math.bignum.md#add-a-b "Defined at lib/math/bignum.lisp:35:2"): Returns `A` plus `B`.|[math/bignum](lib.math.bignum.md)|
| |[`add-action`](lib.io.argparse.md#add-action-arg-data-value "Defined at lib/io/argparse.lisp:41:2"): Append `VALUE` to the appropriate key in `DATA` for `ARG`.|[io/argparse](lib.io.argparse.md)|
| |[`add-argument!`](lib.io.argparse.md#add-argument-spec-names-options "Defined at lib/io/argparse.lisp:57:2"): Add a new argument to `SPEC`, using the specified `NAMES`.|[io/argparse](lib.io.argparse.md)|
| |[`add-category!`](lib.io.argparse.md#add-category-spec-id-name-description "Defined at lib/io/argparse.lisp:149:2"): Add a new category with the given `ID`, display `NAME` and an optional `DESCRIPTION`.|[io/argparse](lib.io.argparse.md)|
| |[`add-edge!`](lib.data.graph.md#add-edge-from-to "Defined at lib/data/graph.lisp:66:2"): Add an edge `FROM` one vertex `TO` another.|[data/graph](lib.data.graph.md)|
| |[`add-help!`](lib.io.argparse.md#add-help-spec "Defined at lib/io/argparse.lisp:136:2"): Add a help argument to `SPEC`.|[io/argparse](lib.io.argparse.md)|
| |[`add-pass!`](lib.compiler.pass.md#add-pass- "Native defined at lib/compiler/pass.lisp:69:1"): Register a `PASS` created with `defpass`.|[compiler/pass](lib.compiler.pass.md)|
| |[`add-vertex!`](lib.data.graph.md#add-vertex-graph-value "Defined at lib/data/graph.lisp:45:2"): Create a vertex with the corresponding `VALUE` and add it to the `GRAPH`.|[data/graph](lib.data.graph.md)|
| |[`affirm`](lib.test.assert.md#affirm-asserts "Macro defined at lib/test/assert.lisp:12:2"): Assert each expression in `ASSERTS` evaluates to true|[test/assert](lib.test.assert.md "Also exported from prelude, test")|
| |[`alignof`](lib.luajit.ffi.md#alignof "Native defined at lib/luajit/ffi.lisp:5:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`alive?`](lib.control.prompt.md#alive-k "Defined at lib/control/prompt.lisp:159:2"): Check that the continuation `K` may be executed further.|[control/prompt](lib.control.prompt.md)|
| |[`all`](lib.core.list.md#all-p-xs "Defined at lib/core/list.lisp:310:2"): Test if all elements of `XS` match the predicate `P`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`and`](lib.core.base.md#and-a-b-rest "Macro defined at lib/core/base.lisp:274:2"): Return the logical and of values `A` and `B`, and, if present, the logical and of all the values in `REST`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`angle`](lib.math.complex.md#angle-z "Defined at lib/math/complex.lisp:149:2"): Get the angle of complex number `Z`.|[math/complex](lib.math.complex.md)|
| |[`angle`](lib.math.vector.md#angle-x-y "Defined at lib/math/vector.lisp:166:2"): Compute the angle between vectors `X` and `Y`.|[math/vector](lib.math.vector.md)|
| |[`any`](lib.core.list.md#any-p-xs "Defined at lib/core/list.lisp:239:2"): Check for the existence of an element in `XS` that matches the predicate `P`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`append`](lib.core.list.md#append-xs-ys "Defined at lib/core/list.lisp:556:2"): Concatenate `XS` and `YS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`append-all!`](lib.io.init.md#append-all-path-data "Defined at lib/io/init.lisp:103:2"): Appends the string `DATA` to the file at `PATH`.|[io](lib.io.init.md)|
| |[`append-bytes!`](lib.io.init.md#append-bytes-path-data "Defined at lib/io/init.lisp:128:2"): Appends the bytes (list of numbers) `DATA` to the file at `PATH`.|[io](lib.io.init.md)|
| |[`append-lines!`](lib.io.init.md#append-lines-path-data "Defined at lib/io/init.lisp:115:2"): Appends the lines (list of strings) `DATA` to the file at `PATH`.|[io](lib.io.init.md)|
| |[`apply`](lib.core.base.md#apply-f-xss-xs "Defined at lib/core/base.lisp:438:2"): Apply the function `F` using `XS` as the argument list, with `XSS` as arguments before `XS` is spliced.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`arch`](lib.luajit.ffi.md#arch "Native defined at lib/luajit/ffi.lisp:12:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`arg`](lib.core.base.md#arg "Defined at lib/core/base.lisp:379:1"): The arguments passed to the currently executing program|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`arg#`](lib.lua.basic.md#arg- "Native defined at lib/lua/basic.lisp:18:1")|[lua/basic](lib.lua.basic.md)|
| |[`as-is`](lib.data.function.md#as-is-x "Defined at lib/data/function.lisp:134:2"): Return the value `X` unchanged.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`ashr`](lib.lua.bit32.md#ashr "Native defined at lib/lua/bit32.lisp:1:1"): Returns the arithmetic right shift of `X` shifted right by `DISP`.|[lua/bit32](lib.lua.bit32.md)|
| |[`asin`](lib.lua.math.md#asin "Native defined at lib/lua/math.lisp:3:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`assert`](lib.lua.basic.md#assert "Native defined at lib/lua/basic.lisp:21:1")|[lua/basic](lib.lua.basic.md)|
| |[`assert!`](lib.test.assert.md#assert-cnd-msg "Macro defined at lib/test/assert.lisp:8:2"): Assert `CND` is true, otherwise failing with `MSG`|[test/assert](lib.test.assert.md "Also exported from test")|
| |[`assert-type!`](lib.core.type.md#assert-type-arg-ty "Macro defined at lib/core/type.lisp:118:2"): Assert that the argument `ARG` has type `TY`, as reported by the function `type`.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`assoc`](lib.data.alist.md#assoc-list-key-or-val "Defined at lib/data/alist.lisp:3:2"): Return the value given by `KEY` in the association list `LIST`, or, in the case that it does not exist, the value `OR-VAL`, which can be nil.|[data/alist](lib.data.alist.md "Also exported from prelude")|
| |[`assoc->struct`](lib.data.alist.md#assoc-struct-list "Defined at lib/data/alist.lisp:72:2"): Convert the association list `LIST` into a structure.|[data/alist](lib.data.alist.md "Also exported from prelude")|
| |[`assoc?`](lib.data.alist.md#assoc-list-key "Defined at lib/data/alist.lisp:22:2"): Check that `KEY` is bound in the association list `LIST`.|[data/alist](lib.data.alist.md "Also exported from prelude")|
| |[`at`](lib.data.lens.md#at-k "Defined at lib/data/lens.lisp:223:2"): `A` lens that focuses on the K-th element of a list.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`atan`](lib.lua.math.md#atan "Native defined at lib/lua/math.lisp:4:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`atan2`](lib.lua.math.md#atan- "Native defined at lib/lua/math.lisp:5:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`atom?`](lib.core.type.md#atom-x "Defined at lib/core/type.lisp:58:2"): Check whether `X` is an atomic object, that is, one of - `A` boolean - `A` string - `A` number - `A` symbol - `A` key - `A` function|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| <strong id="sym-b">b</strong> | |
| |[`between?`](lib.core.type.md#between-val-min-max "Defined at lib/core/type.lisp:86:2"): Check if the numerical value `X` is between `MIN` and `MAX`.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`bit-and`](lib.lua.bit32.md#bit-and "Native defined at lib/lua/bit32.lisp:5:1"): Returns the bitwise `AND` of its arguments.|[lua/bit32](lib.lua.bit32.md)|
| |[`bit-at`](lib.math.bignum.md#bit-at-a-bit "Defined at lib/math/bignum.lisp:187:2"): Returns the value of the bit (0 or 1) of `A` at position `BIT`.|[math/bignum](lib.math.bignum.md)|
| |[`bit-extract`](lib.lua.bit32.md#bit-extract "Native defined at lib/lua/bit32.lisp:15:1"): Returns the unsigned number formed by splicing the bits `FIELD` to   `FIELD` + `WIDTH` - 1 from `X`.|[lua/bit32](lib.lua.bit32.md)|
| |[`bit-not`](lib.lua.bit32.md#bit-not "Native defined at lib/lua/bit32.lisp:7:1"): Returns the bitwise `NOT` of `X`.|[lua/bit32](lib.lua.bit32.md)|
| |[`bit-or`](lib.lua.bit32.md#bit-or "Native defined at lib/lua/bit32.lisp:9:1"): Returns the bitwise `OR` of its arguments.|[lua/bit32](lib.lua.bit32.md)|
| |[`bit-replace`](lib.lua.bit32.md#bit-replace "Native defined at lib/lua/bit32.lisp:20:1"): Returns `X` with the bits `FIELD` to `FIELD` + `WIDTH` - 1 replaced with   the unsigned number value of `V`.|[lua/bit32](lib.lua.bit32.md)|
| |[`bit-rotl`](lib.lua.bit32.md#bit-rotl "Native defined at lib/lua/bit32.lisp:25:1"): Returns `X` rotated left by `DISP`.|[lua/bit32](lib.lua.bit32.md)|
| |[`bit-rotr`](lib.lua.bit32.md#bit-rotr "Native defined at lib/lua/bit32.lisp:29:1"): Returns `X` rotated right by `DISP`.|[lua/bit32](lib.lua.bit32.md)|
| |[`bit-test`](lib.lua.bit32.md#bit-test "Native defined at lib/lua/bit32.lisp:11:1"): Returns true if the bitwise `AND` of its arguments is not 0.|[lua/bit32](lib.lua.bit32.md)|
| |[`bit-xor`](lib.lua.bit32.md#bit-xor "Native defined at lib/lua/bit32.lisp:13:1"): Returns the bitwise `XOR` of its arguments.|[lua/bit32](lib.lua.bit32.md)|
| |[`block`](lib.control.prompt.md#block-body "Macro defined at lib/control/prompt.lisp:177:2"): Estabilish an escape continuation called `break` and evaluate `BODY`.|[control/prompt](lib.control.prompt.md)|
| |[`bool->string`](lib.core.prelude.md#bool-string "Defined at lib/core/prelude.lisp:52:1"): Convert the boolean `X` into a string.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`boolean?`](lib.core.type.md#boolean-x "Defined at lib/core/type.lisp:42:2"): Check whether `X` is a boolean.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`builtin`](lib.compiler.nodes.md#builtin "Native defined at lib/compiler/nodes.lisp:55:1"): Get the builtin with the given `NAME`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`builtin?`](lib.compiler.nodes.md#builtin- "Native defined at lib/compiler/nodes.lisp:46:1"): Determine whether the specified `NODE` is the given `BUILTIN`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`byte`](lib.lua.string.md#byte "Native defined at lib/lua/string.lisp:1:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| <strong id="sym-c">c</strong> | |
| |[`C`](lib.luajit.ffi.md#C "Native defined at lib/luajit/ffi.lisp:19:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`caaaar`](lib.core.list.md#caaaar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caaaars`](lib.core.list.md#caaaars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caaadr`](lib.core.list.md#caaadr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caaadrs`](lib.core.list.md#caaadrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caaar`](lib.core.list.md#caaar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caaars`](lib.core.list.md#caaars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caadar`](lib.core.list.md#caadar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caadars`](lib.core.list.md#caadars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caaddr`](lib.core.list.md#caaddr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caaddrs`](lib.core.list.md#caaddrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caadr`](lib.core.list.md#caadr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caadrs`](lib.core.list.md#caadrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caar`](lib.core.list.md#caar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caars`](lib.core.list.md#caars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadaar`](lib.core.list.md#cadaar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadaars`](lib.core.list.md#cadaars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadadr`](lib.core.list.md#cadadr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadadrs`](lib.core.list.md#cadadrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadar`](lib.core.list.md#cadar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadars`](lib.core.list.md#cadars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caddar`](lib.core.list.md#caddar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caddars`](lib.core.list.md#caddars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadddr`](lib.core.list.md#cadddr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadddrs`](lib.core.list.md#cadddrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caddr`](lib.core.list.md#caddr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`caddrs`](lib.core.list.md#caddrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadr`](lib.core.list.md#cadr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cadrs`](lib.core.list.md#cadrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`call`](lib.data.function.md#call-x-key-args "Defined at lib/data/function.lisp:158:2"): Index `X` with `KEY` and invoke the resulting function with `ARGS`.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`call-with-escape-continuation`](lib.control.prompt.md#call-with-escape-continuation-body "Defined at lib/control/prompt.lisp:73:2"): Invoke the thunk `BODY` with an escape continuation.|[control/prompt](lib.control.prompt.md)|
| |[`call-with-prompt`](lib.control.prompt.md#call-with-prompt-prompt-tag-body-handler "Defined at lib/control/prompt.lisp:24:2"): Call the thunk `BODY` with a prompt `PROMPT-TAG` in scope.|[control/prompt](lib.control.prompt.md)|
| |[`call/ec`](lib.control.prompt.md#call-ec "Defined at lib/control/prompt.lisp:108:1")|[control/prompt](lib.control.prompt.md)|
| |[`call/p`](lib.control.prompt.md#call-p "Defined at lib/control/prompt.lisp:66:1")|[control/prompt](lib.control.prompt.md)|
| |[`can`](lib.test.init.md#can-name-body "Macro defined at lib/test/init.lisp:77:2"): Create a test whose `BODY` asserts `NAME` can happen|[test](lib.test.init.md)|
| |[`cannot`](lib.test.init.md#cannot-name-body "Macro defined at lib/test/init.lisp:81:2"): Create a test whose `BODY` asserts `NAME` cannot happen|[test](lib.test.init.md)|
| |[`car`](lib.core.list.md#car-x "Defined at lib/core/list.lisp:34:2"): Return the first element present in the list `X`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`car`](lib.core.base.md#car-xs "Defined at lib/core/base.lisp:131:1")|[core/base](lib.core.base.md)|
| |[`cars`](lib.core.list.md#cars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`case`](lib.core.match.md#case-val-pts "Macro defined at lib/core/match.lisp:406:2"): Match a single value against a series of patterns, evaluating the first body that matches, much like `cond`.|[core/match](lib.core.match.md "Also exported from core/prelude, prelude")|
| |[`cast`](lib.luajit.ffi.md#cast "Native defined at lib/luajit/ffi.lisp:2:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`cdaaar`](lib.core.list.md#cdaaar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdaaars`](lib.core.list.md#cdaaars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdaadr`](lib.core.list.md#cdaadr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdaadrs`](lib.core.list.md#cdaadrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdaar`](lib.core.list.md#cdaar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdaars`](lib.core.list.md#cdaars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdadar`](lib.core.list.md#cdadar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdadars`](lib.core.list.md#cdadars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdaddr`](lib.core.list.md#cdaddr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdaddrs`](lib.core.list.md#cdaddrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdadr`](lib.core.list.md#cdadr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdadrs`](lib.core.list.md#cdadrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdar`](lib.core.list.md#cdar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdars`](lib.core.list.md#cdars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddaar`](lib.core.list.md#cddaar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddaars`](lib.core.list.md#cddaars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddadr`](lib.core.list.md#cddadr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddadrs`](lib.core.list.md#cddadrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddar`](lib.core.list.md#cddar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddars`](lib.core.list.md#cddars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdddar`](lib.core.list.md#cdddar-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdddars`](lib.core.list.md#cdddars-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddddr`](lib.core.list.md#cddddr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddddrs`](lib.core.list.md#cddddrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdddr`](lib.core.list.md#cdddr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdddrs`](lib.core.list.md#cdddrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddr`](lib.core.list.md#cddr-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cddrs`](lib.core.list.md#cddrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdef`](lib.luajit.ffi.md#cdef "Native defined at lib/luajit/ffi.lisp:8:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`cdr`](lib.core.list.md#cdr-x "Defined at lib/core/list.lisp:46:2"): Return the list `X` without the first element present.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`cdr`](lib.core.base.md#cdr-xs "Defined at lib/core/base.lisp:132:1")|[core/base](lib.core.base.md)|
| |[`cdrs`](lib.core.list.md#cdrs-xs "Defined at lib/core/list.lisp:756:1")|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`ceil`](lib.lua.math.md#ceil "Native defined at lib/lua/math.lisp:6:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`changed!`](lib.compiler.pass.md#changed- "Macro defined at lib/compiler/pass.lisp:72:2"): Mark this pass as having a side effect.|[compiler/pass](lib.compiler.pass.md)|
| |[`char`](lib.lua.utf8.md#char "Native defined at lib/lua/utf8.lisp:1:1")|[lua/utf8](lib.lua.utf8.md)|
| |[`char`](lib.lua.string.md#char "Native defined at lib/lua/string.lisp:2:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| |[`char-at`](lib.core.string.md#char-at-xs-x "Defined at lib/core/string.lisp:10:2"): Index the string `XS`, returning the character at position `X`.|[core/string](lib.core.string.md "Also exported from core/prelude, prelude")|
| |[`charpattern`](lib.lua.utf8.md#charpattern "Native defined at lib/lua/utf8.lisp:2:1")|[lua/utf8](lib.lua.utf8.md)|
| |[`check`](lib.test.check.md#check-bindings-props "Macro defined at lib/test/check.lisp:56:2"): Check a set of properties against a set of random variables 100 times.|[test/check](lib.test.check.md "Also exported from test")|
| |[`clock`](lib.lua.os.md#clock "Native defined at lib/lua/os.lisp:1:1")|[lua/os](lib.lua.os.md)|
| |[`close`](lib.lua.io.md#close "Native defined at lib/lua/io.lisp:1:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`codepoint`](lib.lua.utf8.md#codepoint "Native defined at lib/lua/utf8.lisp:3:1")|[lua/utf8](lib.lua.utf8.md)|
| |[`codes`](lib.lua.utf8.md#codes "Native defined at lib/lua/utf8.lisp:4:1")|[lua/utf8](lib.lua.utf8.md)|
| |[`collectgarbage`](lib.lua.basic.md#collectgarbage "Native defined at lib/lua/basic.lisp:22:1")|[lua/basic](lib.lua.basic.md)|
| |[`coloured`](lib.io.term.md#coloured "Defined at lib/io/term.lisp:24:1"): Color a string `MSG` using `COL` if supported under the current terminal|[io/term](lib.io.term.md)|
| |[`coloured?`](lib.io.term.md#coloured- "Defined at lib/io/term.lisp:9:1"): Constant defining whether the current terminal has colour support|[io/term](lib.io.term.md)|
| |[`comp`](lib.data.function.md#comp-fs "Defined at lib/data/function.lisp:112:2"): Return the pointwise composition of all functions in `FS`.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`complex`](lib.math.complex.md#complex "Defined at lib/math/complex.lisp:16:2"): Represents a complex number, formed of a `real` and `imaginary` part.|[math/complex](lib.math.complex.md)|
| |[`complex?`](lib.math.complex.md#complex-complex "Defined at lib/math/complex.lisp:16:2")|[math/complex](lib.math.complex.md)|
| |[`compose`](lib.data.function.md#compose-f-g "Defined at lib/data/function.lisp:98:2"): Return the pointwise composition of functions `F` and `G`.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`concat`](lib.lua.table.md#concat "Native defined at lib/lua/table.lisp:1:1")|[lua/table](lib.lua.table.md "Also exported from core/base, core/prelude, core/string, prelude")|
| |[`condensation`](lib.data.graph.md#condensation-in-graph "Defined at lib/data/graph.lisp:145:2"): Compute the condensation of an input graph, `IN-GRAPH`, replacing all strongly connected components with a super vertex.|[data/graph](lib.data.graph.md)|
| |[`config`](lib.lua.package.md#config "Native defined at lib/lua/package.lisp:1:1")|[lua/package](lib.lua.package.md)|
| |[`conjugate`](lib.math.complex.md#conjugate-z "Defined at lib/math/complex.lisp:91:2"): Get the complex conjugate of `Z`.|[math/complex](lib.math.complex.md)|
| |[`cons`](lib.core.base.md#cons-x-xs "Defined at lib/core/base.lisp:145:2"): Add `X` to the start of the list `XS`.|[core/base](lib.core.base.md)|
| |[`cons`](lib.core.list.md#cons-xs-xss "Defined at lib/core/list.lisp:93:2"): Return a copy of the list `XSS` with the elements `XS` added to its head.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`const`](lib.data.function.md#const-x "Defined at lib/data/function.lisp:144:2"): Return a function which always returns `X`.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`const-val`](lib.core.base.md#const-val-val "Defined at lib/core/base.lisp:391:2"): Get the actual value of `VAL`, an argument to a macro.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`constant?`](lib.compiler.nodes.md#constant- "Native defined at lib/compiler/nodes.lisp:58:1"): Determine whether the specified `NODE` is a constant.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`continuation?`](lib.control.prompt.md#continuation-continuation "Defined at lib/control/prompt.lisp:13:2")|[control/prompt](lib.control.prompt.md)|
| |[`copy`](lib.luajit.ffi.md#copy "Native defined at lib/luajit/ffi.lisp:11:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`copy`](lib.math.bignum.md#copy-a "Defined at lib/math/bignum.lisp:15:2"): Returns a deep copied clone of `A`.|[math/bignum](lib.math.bignum.md)|
| |[`copy-of`](lib.core.table.md#copy-of-struct "Defined at lib/core/table.lisp:123:2"): Create a shallow copy of `STRUCT`.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`cos`](lib.lua.math.md#cos "Native defined at lib/lua/math.lisp:7:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`cpath`](lib.lua.package.md#cpath "Native defined at lib/lua/package.lisp:2:1")|[lua/package](lib.lua.package.md)|
| |[`create`](lib.io.argparse.md#create-description "Defined at lib/io/argparse.lisp:28:2"): Create a new argument parser|[io/argparse](lib.io.argparse.md)|
| |[`create`](lib.lua.coroutine.md#create "Native defined at lib/lua/coroutine.lisp:1:1")|[lua/coroutine](lib.lua.coroutine.md)|
| |[`create-lookup`](lib.core.table.md#create-lookup-values "Defined at lib/core/table.lisp:154:2"): Convert `VALUES` into a lookup table, with each value being converted to a key whose corresponding value is the value's index.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`cross`](lib.math.vector.md#cross-x-y "Defined at lib/math/vector.lisp:131:2"): Compute the vector cross product of `X` and `Y`.|[math/vector](lib.math.vector.md)|
| |[`cut`](lib.data.function.md#cut-func "Macro defined at lib/data/function.lisp:16:2"): Partially apply a function `FUNC`, where each `<>` is replaced by an argument to a function.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`cute`](lib.data.function.md#cute-func "Macro defined at lib/data/function.lisp:37:2"): Partially apply a function `FUNC`, where each `<>` is replaced by an argument to a function.|[data/function](lib.data.function.md "Also exported from prelude")|
| <strong id="sym-d">d</strong> | |
| |[`date`](lib.lua.os.md#date "Native defined at lib/lua/os.lisp:2:1")|[lua/os](lib.lua.os.md)|
| |[`debug`](lib.lua.debug.md#debug "Native defined at lib/lua/debug.lisp:1:1")|[lua/debug](lib.lua.debug.md)|
| |[`debug`](lib.core.type.md#debug-x "Macro defined at lib/core/type.lisp:367:2"): Print the value `X`, then return it unmodified.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`dec!`](lib.math.init.md#dec-x "Macro defined at lib/math/init.lisp:83:2"): Decrements the symbol `X` by 1.|[math](lib.math.init.md "Also exported from prelude")|
| |[`defalias`](lib.core.type.md#defalias-name-other "Macro defined at lib/core/type.lisp:286:2"): Alias the method at `NAME` to the method at `OTHER`.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`defdefault`](lib.core.type.md#defdefault-name-ll-body "Macro defined at lib/core/type.lisp:268:2"): Add a default case to the generic method `NAME` with the arguments `LL` and the body `BODY`.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`defgeneric`](lib.core.type.md#defgeneric-name-ll-attrs "Macro defined at lib/core/type.lisp:165:2"): Define a generic method called `NAME` with the arguments given in `LL`, and the attributes given in `ATTRS`.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`defmacro`](lib.core.base.md#defmacro-name-args-body "Macro defined at lib/core/base.lisp:125:1"): Define `NAME` to be the macro given by (lambda `ARGS` @`BODY`), with optional metadata at the start of `BODY`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`defmethod`](lib.core.type.md#defmethod-name-ll-body "Macro defined at lib/core/type.lisp:236:2"): Add a case to the generic method `NAME` with the arguments `LL` and the body `BODY`.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`defpass`](lib.compiler.pass.md#defpass-name-args-body "Macro defined at lib/compiler/pass.lisp:30:2"): Define a pass with the given `NAME` and `BODY` taking the specified `ARGS`.|[compiler/pass](lib.compiler.pass.md)|
| |[`defstruct`](lib.data.struct.md#defstruct-name-clauses "Macro defined at lib/data/struct.lisp:103:2"): Define a struct called `NAME`.|[data/struct](lib.data.struct.md)|
| |[`defun`](lib.core.base.md#defun-name-args-body "Macro defined at lib/core/base.lisp:119:1"): Define `NAME` to be the function given by (lambda `ARGS` @`BODY`), with optional metadata at the start of `BODY`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`defun-ffi`](lib.luajit.ffi.md#defun-ffi-name-typedecl "Macro defined at lib/luajit/ffi.lisp:22:2"): Define the external symbol `NAME` with the `C` type signature given by `TYPEDECL`.|[luajit/ffi](lib.luajit.ffi.md)|
| |[`deg`](lib.lua.math.md#deg "Native defined at lib/lua/math.lisp:8:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`denominator`](lib.math.rational.md#denominator-rational "Defined at lib/math/rational.lisp:7:2"): The rational's denumerator|[math/rational](lib.math.rational.md "Also exported from prelude")|
| |[`describe`](lib.test.init.md#describe-name-body "Macro defined at lib/test/init.lisp:85:2"): Create a group of tests, defined in `BODY`, which test `NAME`|[test](lib.test.init.md)|
| |[`destructuring-bind`](lib.core.match.md#destructuring-bind-pt-body "Macro defined at lib/core/match.lisp:389:2"): Match a single pattern against a single value, then evaluate the `BODY`.|[core/match](lib.core.match.md "Also exported from core/prelude, prelude")|
| |[`difftime`](lib.lua.os.md#difftime "Native defined at lib/lua/os.lisp:3:1")|[lua/os](lib.lua.os.md)|
| |[`divide`](lib.math.bignum.md#divide-a-b "Defined at lib/math/bignum.lisp:115:2"): Returns `A` divided by `B`.|[math/bignum](lib.math.bignum.md)|
| |[`do`](lib.core.list.md#do-vars-stmts "Macro defined at lib/core/list.lisp:529:2"): Iterate over all given `VARS`, running `STMTS` **without** collecting the results.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`dofile`](lib.lua.basic.md#dofile "Native defined at lib/lua/basic.lisp:23:1")|[lua/basic](lib.lua.basic.md)|
| |[`dolist`](lib.core.list.md#dolist-vars-stmts "Macro defined at lib/core/list.lisp:499:2"): Iterate over all given `VARS`, running `STMTS` and collecting the results.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`dominators`](lib.data.graph.md#dominators-root "Defined at lib/data/graph.lisp:253:2"): Build the dominators from nodes descended from `ROOT`.|[data/graph](lib.data.graph.md)|
| |[`dot`](lib.math.vector.md#dot-x-y "Defined at lib/math/vector.lisp:110:2"): Compute the dot product of vectors `X` and `Y`.|[math/vector](lib.math.vector.md)|
| |[`drop`](lib.core.list.md#drop-xs-n "Defined at lib/core/list.lisp:71:2"): Remove the first `N` elements of the list `XS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`dump`](lib.lua.string.md#dump "Native defined at lib/lua/string.lisp:3:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| <strong id="sym-e">e</strong> | |
| |[`echelon`](lib.math.matrix.md#echelon-matrix "Defined at lib/math/matrix.lisp:128:2"): Reduce the given `MATRIX` to row echelon form.|[math/matrix](lib.math.matrix.md)|
| |[`eighth`](lib.core.base.md#eighth-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md)|
| |[`elem?`](lib.core.list.md#elem-x-xs "Defined at lib/core/list.lisp:331:2"): Test if `X` is present in the list `XS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`element?`](lib.data.set.md#element-set-val "Defined at lib/data/set.lisp:36:2"): Check if `VAL` is an element of `SET`.|[data/set](lib.data.set.md)|
| |[`else`](lib.core.base.md#else "Defined at lib/core/base.lisp:9:1"): `else` is defined as having the value `true`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`empty-struct?`](lib.core.table.md#empty-struct-xs "Defined at lib/core/table.lisp:101:2"): Check that `XS` is the empty struct.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`empty?`](lib.core.type.md#empty-x "Defined at lib/core/type.lisp:18:2"): Check whether `X` is the empty list or the empty string.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`ends-with?`](lib.core.string.md#ends-with-str-suffix "Defined at lib/core/string.lisp:104:2"): Determine whether `STR` ends with `SUFFIX`.|[core/string](lib.core.string.md "Also exported from core/prelude, prelude")|
| |[`eq?`](lib.core.type.md#eq- "Defined at lib/core/type.lisp:291:2"): Compare values for equality deeply.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`eql?`](lib.core.type.md#eql-x-y "Defined at lib/core/type.lisp:104:2"): `A` version of `eq?` that compares the types of `X` and `Y` instead of just the values.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`equals?`](lib.math.bignum.md#equals-a-b "Defined at lib/math/bignum.lisp:246:2"): Returns true if `A` == `B`.|[math/bignum](lib.math.bignum.md)|
| |[`errno`](lib.luajit.ffi.md#errno "Native defined at lib/luajit/ffi.lisp:18:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`error`](lib.lua.basic.md#error "Native defined at lib/lua/basic.lisp:24:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base")|
| |[`error!`](lib.core.prelude.md#error- "Defined at lib/core/prelude.lisp:56:1"): Throw an error.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`even?`](lib.math.init.md#even-x "Defined at lib/math/init.lisp:27:2"): Is `X` an even number?|[math](lib.math.init.md "Also exported from prelude")|
| |[`every`](lib.data.lens.md#every-x-ln "Defined at lib/data/lens.lisp:326:2"): `A` higher-order lens that focuses `LN` on every element of a list that satisfies the perdicate `X`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`exclude`](lib.core.list.md#exclude-p-xs "Defined at lib/core/list.lisp:228:2"): Return a list with only the elements of `XS` that don't match the predicate `P`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`execute`](lib.lua.os.md#execute "Native defined at lib/lua/os.lisp:4:1")|[lua/os](lib.lua.os.md)|
| |[`exists?`](lib.core.type.md#exists-x "Defined at lib/core/type.lisp:76:2"): Check if `X` exists, i.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`exit`](lib.lua.os.md#exit "Native defined at lib/lua/os.lisp:5:1")|[lua/os](lib.lua.os.md)|
| |[`exit!`](lib.core.prelude.md#exit-reason-code "Defined at lib/core/prelude.lisp:69:2"): Exit the program with the exit code `CODE`, and optionally, print the error message `REASON`.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`exp`](lib.lua.math.md#exp "Native defined at lib/lua/math.lisp:9:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`expt`](lib.lua.basic.md#expt "Native defined at lib/lua/basic.lisp:13:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`extend`](lib.data.alist.md#extend-ls-key-val "Defined at lib/data/alist.lisp:48:2"): Extend the association list `LIST`_ by inserting `VAL`, bound to the key `KEY`, overriding any previous value.|[data/alist](lib.data.alist.md "Also exported from prelude")|
| <strong id="sym-f">f</strong> | |
| |[`fail!`](lib.core.prelude.md#fail-x "Defined at lib/core/prelude.lisp:64:2"): Fail with the error message `X`, that is, exit the program immediately, without unwinding for an error handler.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`falsey?`](lib.core.type.md#falsey-x "Defined at lib/core/type.lisp:71:2"): Check whether `X` is falsey, that is, it is either `false` or does not exist.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`fast-struct`](lib.core.table.md#fast-struct-entries "Defined at lib/core/table.lisp:88:2"): `A` variation of `struct`, which will not perform any coercing of the `KEYS` in entries.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`fifth`](lib.core.base.md#fifth-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`fill`](lib.luajit.ffi.md#fill "Native defined at lib/luajit/ffi.lisp:7:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`filter`](lib.core.list.md#filter-p-xs "Defined at lib/core/list.lisp:217:2"): Return a list with only the elements of `XS` that match the predicate `P`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`find`](lib.lua.string.md#find "Native defined at lib/lua/string.lisp:4:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| |[`first`](lib.core.base.md#first-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`fix-symbol`](lib.compiler.nodes.md#fix-symbol-symbol "Defined at lib/compiler/nodes.lisp:38:2"): Convert the quasi-quoted `SYMBOL` into a fully resolved one.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`flag?`](lib.compiler.init.md#flag- "Native defined at lib/compiler/init.lisp:51:1"): Determine whether the given compiler `FLAG` is set.|[compiler](lib.compiler.init.md)|
| |[`flags`](lib.compiler.init.md#flags "Native defined at lib/compiler/init.lisp:48:1"): Get a list of all compiler flags.|[compiler](lib.compiler.init.md)|
| |[`flat-map`](lib.core.list.md#flat-map-fn-xss "Defined at lib/core/list.lisp:187:2"): Map the function `FN` over the lists `XSS`, then flatten the result lists.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`flatten`](lib.core.list.md#flatten-xss "Defined at lib/core/list.lisp:566:2"): Concatenate all the lists in `XSS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`floor`](lib.lua.math.md#floor "Native defined at lib/lua/math.lisp:10:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`flush`](lib.lua.io.md#flush "Native defined at lib/lua/io.lisp:2:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`fmod`](lib.lua.math.md#fmod "Native defined at lib/lua/math.lisp:11:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`folding`](lib.data.lens.md#folding-f-z-l "Defined at lib/data/lens.lisp:294:2"): Transform the (traversing) lens `L` into a getter which folds the result using the function `F` and the zero element `Z`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`for`](lib.core.base.md#for-ctr-start-end-step-body "Macro defined at lib/core/base.lisp:224:2"): Iterate `BODY`, with the counter `CTR` bound to `START`, being incremented by `STEP` every iteration until `CTR` is outside of the range given by [`START` .|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`for-each`](lib.core.list.md#for-each-var-lst-body "Macro defined at lib/core/list.lisp:483:2"): Perform the set of actions `BODY` for all values in `LST`, binding the current value to `VAR`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`for-pairs`](lib.core.base.md#for-pairs-vars-tbl-body "Macro defined at lib/core/base.lisp:352:2"): Iterate over `TBL`, binding `VARS` for each key value pair in `BODY`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`forall`](lib.test.check.md#forall-var-prop "Macro defined at lib/test/check.lisp:154:2"): Check that `PROP` holds across all possible points.|[test/check](lib.test.check.md "Also exported from test")|
| |[`format`](lib.data.format.md#format-out-str-args "Macro defined at lib/data/format.lisp:120:2"): Output the string `STR` formatted against `ARGS` to the stream `OUT`.|[data/format](lib.data.format.md "Also exported from prelude")|
| |[`format`](lib.lua.string.md#format "Native defined at lib/lua/string.lisp:5:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| |[`fourth`](lib.core.base.md#fourth-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`function`](lib.core.match.md#function-arms "Macro defined at lib/core/match.lisp:468:2"): Create a lambda which matches its arguments against the patterns defined in `ARMS`.|[core/match](lib.core.match.md "Also exported from core/prelude, prelude")|
| |[`function?`](lib.core.type.md#function-x "Defined at lib/core/type.lisp:48:2"): Check whether `X` is a function.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`fusion/add-rule!`](lib.compiler.optimise.md#fusion-add-rule- "Native defined at lib/compiler/optimise.lisp:3:1"): Register a new fusion rule.|[compiler/optimise](lib.compiler.optimise.md)|
| |[`fusion/defrule`](lib.compiler.optimise.md#fusion-defrule-from-to "Macro defined at lib/compiler/optimise.lisp:5:2"): Define a rewrite rule which maps `FROM` to `TO`.|[compiler/optimise](lib.compiler.optimise.md)|
| <strong id="sym-g">g</strong> | |
| |[`gc`](lib.luajit.ffi.md#gc "Native defined at lib/luajit/ffi.lisp:17:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`gcd`](lib.math.init.md#gcd-x-y "Defined at lib/math/init.lisp:3:2"): Compute the greatest common divisor of `X` and `Y`.|[math](lib.math.init.md "Also exported from prelude")|
| |[`gensym`](lib.core.base.md#gensym "Defined at lib/core/base.lisp:200:1"): Create a unique symbol, suitable for using in macros|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`get-idx`](lib.lua.basic.md#get-idx "Native defined at lib/lua/basic.lisp:34:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base")|
| |[`get-vertex`](lib.data.graph.md#get-vertex-graph-value "Defined at lib/data/graph.lisp:58:2"): Get the corresponding vertex for this `VALUE` from the given `GRAPH`.|[data/graph](lib.data.graph.md)|
| |[`getenv`](lib.lua.os.md#getenv "Native defined at lib/lua/os.lisp:6:1")|[lua/os](lib.lua.os.md)|
| |[`gethook`](lib.lua.debug.md#gethook "Native defined at lib/lua/debug.lisp:2:1")|[lua/debug](lib.lua.debug.md)|
| |[`getinfo`](lib.lua.debug.md#getinfo "Native defined at lib/lua/debug.lisp:3:1")|[lua/debug](lib.lua.debug.md)|
| |[`getlocal`](lib.lua.debug.md#getlocal "Native defined at lib/lua/debug.lisp:4:1")|[lua/debug](lib.lua.debug.md)|
| |[`getmetatable`](lib.lua.debug.md#getmetatable "Native defined at lib/lua/debug.lisp:5:1")|[lua/debug](lib.lua.debug.md)|
| |[`getmetatable`](lib.lua.basic.md#getmetatable "Native defined at lib/lua/basic.lisp:25:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`getregistry`](lib.lua.debug.md#getregistry "Native defined at lib/lua/debug.lisp:6:1")|[lua/debug](lib.lua.debug.md)|
| |[`getter`](lib.data.lens.md#getter-view "Defined at lib/data/lens.lisp:88:2"): Define a getting lens using `VIEW` as the accessor.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`getter?`](lib.data.lens.md#getter-lens "Defined at lib/data/lens.lisp:110:2"): Check that `LENS` has a defined getter, along with being tagged as a `LENS`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`getupvalue`](lib.lua.debug.md#getupvalue "Native defined at lib/lua/debug.lisp:7:1")|[lua/debug](lib.lua.debug.md)|
| |[`getuservalue`](lib.lua.debug.md#getuservalue "Native defined at lib/lua/debug.lisp:8:1")|[lua/debug](lib.lua.debug.md)|
| |[`graph->dot`](lib.data.graph.md#graph-dot-graph-name "Defined at lib/data/graph.lisp:28:2"): Convert `GRAPH` to a string in the `DOT` format, suitable for consumption with GraphViz.|[data/graph](lib.data.graph.md)|
| |[`graph?`](lib.data.graph.md#graph-graph "Defined at lib/data/graph.lisp:9:2")|[data/graph](lib.data.graph.md)|
| |[`groups-of`](lib.core.list.md#groups-of-xs-num "Defined at lib/core/list.lisp:705:2"): Splits the list `XS` into sub-lists of size `NUM`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`gsub`](lib.lua.string.md#gsub "Native defined at lib/lua/string.lisp:6:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| <strong id="sym-h">h</strong> | |
| |[`handler-case`](lib.core.match.md#handler-case-x-body "Macro defined at lib/core/match.lisp:437:2"): Evaluate the form `X`, and if an error happened, match the series of `(?pattern . ?body)` arms given in `BODY` against the value of the error, executing the first that succeeeds.|[core/match](lib.core.match.md "Also exported from core/prelude, prelude")|
| |[`head`](lib.data.lens.md#head "Defined at lib/data/lens.lisp:201:1"): `A` lens equivalent to `car`, which `view`s and applies `over` the first element of a list.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`height`](lib.math.matrix.md#height-matrix "Defined at lib/math/matrix.lisp:6:2"): The height of this matrix.|[math/matrix](lib.math.matrix.md)|
| |[`help!`](lib.io.argparse.md#help-spec-name "Defined at lib/io/argparse.lisp:198:2"): Display the help for the argument parser as defined in `SPEC`.|[io/argparse](lib.io.argparse.md)|
| |[`huge`](lib.lua.math.md#huge "Native defined at lib/lua/math.lisp:12:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| <strong id="sym-i">i</strong> | |
| |[`id`](lib.data.function.md#id-x "Defined at lib/data/function.lisp:124:2"): Return the value `X` unmodified.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`identity`](lib.math.matrix.md#identity-dim "Defined at lib/math/matrix.lisp:32:2"): Create the identity matrix with the given `DIM`.|[math/matrix](lib.math.matrix.md)|
| |[`if`](lib.core.base.md#if-c-t-b "Macro defined at lib/core/base.lisp:162:2"): Evaluate `T` if `C` is true, otherwise, evaluate `B`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`if-let`](lib.core.binders.md#if-let-vars-then-else "Macro defined at lib/core/binders.lisp:134:2"): Evaluate `THEN` or `ELSE`, depending on the truthiness of all variables bound (as per `let`) in `VARS`.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`if-match`](lib.core.match.md#if-match-cs-t-e "Macro defined at lib/core/match.lisp:483:2"): Matches a pattern against a value defined in `CS`, evaluating `T` with the captured variables in scope if the pattern succeeded, otherwise evaluating `E`.|[core/match](lib.core.match.md "Also exported from core/prelude, prelude")|
| |[`if-with`](lib.core.binders.md#if-with-var-then-else "Macro defined at lib/core/binders.lisp:152:2"): Bind the pair `VAR` of the form `(name value)`, evaluating `THEN` if the value is truthy or `ELSE` if not.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`imaginary`](lib.math.complex.md#imaginary-complex "Defined at lib/math/complex.lisp:16:2"): The imaginary part of this `complex` number.|[math/complex](lib.math.complex.md)|
| |[`inc!`](lib.math.init.md#inc-x "Macro defined at lib/math/init.lisp:71:2"): Increments the symbol `X` by 1.|[math](lib.math.init.md "Also exported from prelude")|
| |[`init`](lib.core.list.md#init-xs "Defined at lib/core/list.lisp:379:2"): Return the list `XS` with the last element removed.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`input`](lib.lua.io.md#input "Native defined at lib/lua/io.lisp:3:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`insert`](lib.lua.table.md#insert "Native defined at lib/lua/table.lisp:2:1")|[lua/table](lib.lua.table.md)|
| |[`insert`](lib.data.alist.md#insert-alist-key-val "Defined at lib/data/alist.lisp:37:2"): Extend the association list `ALIST` by inserting `VAL`, bound to the key `KEY`.|[data/alist](lib.data.alist.md "Also exported from prelude")|
| |[`insert`](lib.data.set.md#insert-set-vals "Defined at lib/data/set.lisp:67:2"): Build a copy of `SET` with VALs inserted.|[data/set](lib.data.set.md)|
| |[`insert!`](lib.data.set.md#insert-set-vals "Defined at lib/data/set.lisp:48:2"): Insert `VALS` into `SET`.|[data/set](lib.data.set.md)|
| |[`insert!`](lib.data.alist.md#insert-alist-key-val "Defined at lib/data/alist.lisp:59:2"): Extend the association list `ALIST` in place by inserting `VAL`, bound to the key `KEY`.|[data/alist](lib.data.alist.md "Also exported from prelude")|
| |[`insert-nth!`](lib.core.list.md#insert-nth-li-idx-val "Defined at lib/core/list.lisp:469:2"): Mutate the list `LI`, inserting `VAL` at `IDX`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`intersection`](lib.data.set.md#intersection-a-b "Defined at lib/data/set.lisp:103:2"): The set of values that occur in both `A` and `B`.|[data/set](lib.data.set.md)|
| |[`invert`](lib.math.matrix.md#invert-matrix "Defined at lib/math/matrix.lisp:206:2"): Invert the provided `MATRIX`.|[math/matrix](lib.math.matrix.md)|
| |[`invokable?`](lib.data.function.md#invokable-x "Defined at lib/data/function.lisp:80:2"): Test if the expression `X` makes sense as something that can be applied to a set of arguments.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`ipairs`](lib.lua.basic.md#ipairs "Native defined at lib/lua/basic.lisp:26:1")|[lua/basic](lib.lua.basic.md)|
| |[`is`](lib.test.init.md#is-name-body "Macro defined at lib/test/init.lisp:73:2"): Create a test whose `BODY` asserts `NAME` is true|[test](lib.test.init.md)|
| |[`istype`](lib.luajit.ffi.md#istype "Native defined at lib/luajit/ffi.lisp:6:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`isyieldable`](lib.lua.coroutine.md#isyieldable "Native defined at lib/lua/coroutine.lisp:2:1")|[lua/coroutine](lib.lua.coroutine.md)|
| |[`it`](lib.test.init.md#it-name-body "Macro defined at lib/test/init.lisp:32:2"): Create a test `NAME` which executes all expressions and assertions in `BODY`|[test](lib.test.init.md)|
| |[`it`](lib.data.lens.md#it "Defined at lib/data/lens.lisp:191:1"): The simplest lens, not focusing on any subcomponent.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`iter-pairs`](lib.core.table.md#iter-pairs-table-func "Defined at lib/core/table.lisp:119:2"): Iterate over `TABLE` with a function `FUNC` of the form `(lambda (key val) ...)`|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| <strong id="sym-k">k</strong> | |
| |[`key?`](lib.core.type.md#key-x "Defined at lib/core/type.lisp:54:2"): Check whether `X` is a key.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`keys`](lib.core.table.md#keys-st "Defined at lib/core/table.lisp:137:2"): Return the keys in the structure `ST`.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| <strong id="sym-l">l</strong> | |
| |[`lambda`](lib.core.base.md#lambda-ll-body "Macro defined at lib/core/base.lisp:54:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`last`](lib.core.list.md#last-xs "Defined at lib/core/list.lisp:367:2"): Return the last element of the list `XS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`lcm`](lib.math.init.md#lcm-x-y "Defined at lib/math/init.lisp:16:2"): Compute the lowest common multiple of `X` and `Y`.|[math](lib.math.init.md "Also exported from prelude")|
| |[`len`](lib.lua.string.md#len "Native defined at lib/lua/string.lisp:7:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| |[`len`](lib.lua.utf8.md#len "Native defined at lib/lua/utf8.lisp:5:1")|[lua/utf8](lib.lua.utf8.md)|
| |[`len#`](lib.lua.basic.md#len- "Native defined at lib/lua/basic.lisp:19:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, core/table, prelude")|
| |[`length`](lib.math.bignum.md#length-a "Defined at lib/math/bignum.lisp:194:2"): Returns the amount of numerical bits needed to contain `A`.|[math/bignum](lib.math.bignum.md)|
| |[`lens`](lib.data.lens.md#lens-view-over "Defined at lib/data/lens.lisp:75:2"): Define a lens using `VIEW` and `OVER` as the getter and the replacer functions, respectively.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`lens?`](lib.data.lens.md#lens-lens "Defined at lib/data/lens.lisp:102:2"): Check that is `LENS` a valid lens, that is, has the proper tag, a valid getter and a valid setter.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`less-or-equal?`](lib.math.bignum.md#less-or-equal-a-b "Defined at lib/math/bignum.lisp:278:2"): Returns true if `A` <= `B`.|[math/bignum](lib.math.bignum.md)|
| |[`less-than?`](lib.math.bignum.md#less-than-a-b "Defined at lib/math/bignum.lisp:255:2"): Returns true if `A` < `B`.|[math/bignum](lib.math.bignum.md)|
| |[`let`](lib.core.binders.md#let-vars-body "Macro defined at lib/core/binders.lisp:55:2"): Bind several variables (given in `VARS`), then evaluate `BODY`.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`let*`](lib.core.binders.md#let-vars-body "Macro defined at lib/core/binders.lisp:30:2"): Bind several variables (given in `VARS`), then evaluate `BODY`.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`let*`](lib.core.base.md#let-vars-body "Macro defined at lib/core/base.lisp:180:2")|[core/base](lib.core.base.md)|
| |[`let-escape-continuation`](lib.control.prompt.md#let-escape-continuation-k-body "Macro defined at lib/control/prompt.lisp:94:2"): Bind `K` within `BODY` to an escape continuation.|[control/prompt](lib.control.prompt.md)|
| |[`let-prompt`](lib.control.prompt.md#let-prompt-tg-e-h "Macro defined at lib/control/prompt.lisp:68:2"): Evaluate `E` in a prompt with the tag `TG` and handler `H`.|[control/prompt](lib.control.prompt.md)|
| |[`let/ec`](lib.control.prompt.md#let-ec "Macro defined at lib/control/prompt.lisp:109:1")|[control/prompt](lib.control.prompt.md)|
| |[`let/p`](lib.control.prompt.md#let-p "Macro defined at lib/control/prompt.lisp:71:1")|[control/prompt](lib.control.prompt.md)|
| |[`letrec`](lib.core.binders.md#letrec-vars-body "Macro defined at lib/core/binders.lisp:177:2"): Bind several variables (given in `VARS`), which may be recursive.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`lines`](lib.lua.io.md#lines "Native defined at lib/lua/io.lisp:4:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`list`](lib.core.base.md#list-xs "Defined at lib/core/base.lisp:134:2"): Return the list of variadic arguments given.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`list->struct`](lib.core.table.md#list-struct-list "Defined at lib/core/table.lisp:32:2"): Converts a `LIST` to a structure, mapping an index to the element in the list.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`list->vector`](lib.math.vector.md#list-vector-items "Defined at lib/math/vector.lisp:31:2"): Create a new vector from a list of values.|[math/vector](lib.math.vector.md)|
| |[`list?`](lib.core.type.md#list-x "Defined at lib/core/type.lisp:14:2"): Check whether `X` is a list.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`load`](lib.lua.basic.md#load "Native defined at lib/lua/basic.lisp:27:1")|[lua/basic](lib.lua.basic.md)|
| |[`load`](lib.luajit.ffi.md#load "Native defined at lib/luajit/ffi.lisp:14:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`loaded`](lib.lua.package.md#loaded "Native defined at lib/lua/package.lisp:3:1")|[lua/package](lib.lua.package.md)|
| |[`loadfile`](lib.lua.basic.md#loadfile "Native defined at lib/lua/basic.lisp:28:1")|[lua/basic](lib.lua.basic.md)|
| |[`loadlib`](lib.lua.package.md#loadlib "Native defined at lib/lua/package.lisp:4:1")|[lua/package](lib.lua.package.md)|
| |[`log`](lib.lua.math.md#log "Native defined at lib/lua/math.lisp:13:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`logger/do-node-error!`](lib.compiler.init.md#logger-do-node-error- "Native defined at lib/compiler/init.lisp:34:1"): Push an error message to the logger, then fail.|[compiler](lib.compiler.init.md)|
| |[`logger/put-debug!`](lib.compiler.init.md#logger-put-debug- "Native defined at lib/compiler/init.lisp:13:1"): Push an verbose message `MSG` to the logger|[compiler](lib.compiler.init.md)|
| |[`logger/put-error!`](lib.compiler.init.md#logger-put-error- "Native defined at lib/compiler/init.lisp:4:1"): Push an error message `MSG` to the logger|[compiler](lib.compiler.init.md)|
| |[`logger/put-node-error!`](lib.compiler.init.md#logger-put-node-error- "Native defined at lib/compiler/init.lisp:16:1"): Push a defailed error message to the logger.|[compiler](lib.compiler.init.md)|
| |[`logger/put-node-warning!`](lib.compiler.init.md#logger-put-node-warning- "Native defined at lib/compiler/init.lisp:25:1"): Push a warning message to the logger.|[compiler](lib.compiler.init.md)|
| |[`logger/put-verbose!`](lib.compiler.init.md#logger-put-verbose- "Native defined at lib/compiler/init.lisp:10:1"): Push an verbose message `MSG` to the logger|[compiler](lib.compiler.init.md)|
| |[`logger/put-warning!`](lib.compiler.init.md#logger-put-warning- "Native defined at lib/compiler/init.lisp:7:1"): Push an warning message `MSG` to the logger|[compiler](lib.compiler.init.md)|
| |[`loop`](lib.core.binders.md#loop-vs-test-body "Macro defined at lib/core/binders.lisp:225:2"): `A` general iteration helper.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`lower`](lib.lua.string.md#lower "Native defined at lib/lua/string.lisp:8:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| <strong id="sym-m">m</strong> | |
| |[`magnitude`](lib.math.complex.md#magnitude-z "Defined at lib/math/complex.lisp:135:2"): Get the magnitude of complex number `Z`.|[math/complex](lib.math.complex.md)|
| |[`make-graph`](lib.data.graph.md#make-graph "Defined at lib/data/graph.lisp:9:2"): Create a new, empty graph.|[data/graph](lib.data.graph.md)|
| |[`make-set`](lib.data.set.md#make-set "Defined at lib/data/set.lisp:6:2"): Create a new, empty set with the given `HASH-FUNCTION`.|[data/set](lib.data.set.md)|
| |[`map`](lib.core.list.md#map-fn-xss "Defined at lib/core/list.lisp:134:2"): Iterate over all the successive cars of `XSS`, producing a single list by applying `FN` to all of them.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`match`](lib.compiler.pattern.md#match-ptrn-expr "Defined at lib/compiler/pattern.lisp:101:2"): Determine whether `EXPR` matches the provided pattern `PTRN`, returning nil or a lookup of capture names to captured expressions.|[compiler/pattern](lib.compiler.pattern.md)|
| |[`match`](lib.lua.string.md#match "Native defined at lib/lua/string.lisp:9:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| |[`match-always`](lib.compiler.pattern.md#match-always-ptrn-expr "Defined at lib/compiler/pattern.lisp:118:2")|[compiler/pattern](lib.compiler.pattern.md)|
| |[`matcher`](lib.compiler.pattern.md#matcher-ptrn "Macro defined at lib/compiler/pattern.lisp:111:2"): Create a matcher for the given pattern literal `PTRN`.|[compiler/pattern](lib.compiler.pattern.md)|
| |[`matches?`](lib.core.match.md#matches-pt-x "Macro defined at lib/core/match.lisp:427:2"): Test if the value `X` matches the pattern `PT`.|[core/match](lib.core.match.md "Also exported from core/prelude, prelude")|
| |[`matches?`](lib.compiler.pattern.md#matches-ptrn-expr "Defined at lib/compiler/pattern.lisp:107:2"): Determine whether `EXPR` matches the provided pattern `PTRN`.|[compiler/pattern](lib.compiler.pattern.md)|
| |[`matrix`](lib.math.matrix.md#matrix-width-height-items "Defined at lib/math/matrix.lisp:13:2"): Create a new matrix with the given `WIDTH` and `HEIGHT`.|[math/matrix](lib.math.matrix.md)|
| |[`matrix-item`](lib.math.matrix.md#matrix-item-matrix-y-x "Defined at lib/math/matrix.lisp:48:2"): Get the item in the provided `MATRIX` at `Y` `X`.|[math/matrix](lib.math.matrix.md)|
| |[`matrix?`](lib.math.matrix.md#matrix-matrix "Defined at lib/math/matrix.lisp:6:2")|[math/matrix](lib.math.matrix.md)|
| |[`max`](lib.lua.math.md#max "Native defined at lib/lua/math.lisp:14:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`maxinteger`](lib.lua.math.md#maxinteger "Native defined at lib/lua/math.lisp:15:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`may`](lib.test.init.md#may-name-body "Macro defined at lib/test/init.lisp:60:2"): Create a group of tests defined in `BODY` whose names take the form `<prefix> may NAME, and <test_name>`|[test](lib.test.init.md)|
| |[`maybe-map`](lib.core.list.md#maybe-map-fn-xss "Defined at lib/core/list.lisp:158:2"): Iterate over all successive cars of `XSS`, producing a single list by applying `FN` to all of them, while discarding any `nil`s.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`merge`](lib.core.table.md#merge-structs "Defined at lib/core/table.lisp:129:2"): Merge all tables in `STRUCTS` together into a new table.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`metatype`](lib.luajit.ffi.md#metatype "Native defined at lib/luajit/ffi.lisp:10:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`min`](lib.lua.math.md#min "Native defined at lib/lua/math.lisp:16:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`mininteger`](lib.lua.math.md#mininteger "Native defined at lib/lua/math.lisp:17:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`mod`](lib.lua.basic.md#mod "Native defined at lib/lua/basic.lisp:12:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`modf`](lib.lua.math.md#modf "Native defined at lib/lua/math.lisp:18:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`modulo`](lib.math.bignum.md#modulo-a-b "Defined at lib/math/bignum.lisp:125:2"): Returns the remainder of `A` divided by `B`.|[math/bignum](lib.math.bignum.md)|
| |[`move`](lib.lua.table.md#move "Native defined at lib/lua/table.lisp:3:1")|[lua/table](lib.lua.table.md)|
| |[`multiply`](lib.math.bignum.md#multiply-a-b "Defined at lib/math/bignum.lisp:82:2"): Returns `A` multiplied by `B`.|[math/bignum](lib.math.bignum.md)|
| <strong id="sym-n">n</strong> | |
| |[`n`](lib.core.base.md#n-x "Defined at lib/core/base.lisp:14:1"): Get the length of list X|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`n*`](lib.math.numerics.md#n- "Defined at lib/math/numerics.lisp:5:2"): Generalised numeric cross product.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`n+`](lib.math.numerics.md#n- "Defined at lib/math/numerics.lisp:3:2"): Generalised numeric addition.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`n-`](lib.math.numerics.md#n- "Defined at lib/math/numerics.lisp:4:2"): Generalised numeric subtraction.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`n/`](lib.math.numerics.md#n- "Defined at lib/math/numerics.lisp:6:2"): Generalised numeric division.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`n<`](lib.math.numerics.md#n- "Defined at lib/math/numerics.lisp:9:2"): Generalised numeric less-than comparison.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`n<=`](lib.math.numerics.md#n- "Defined at lib/math/numerics.lisp:10:2"): Generalised numeric less-than or equal to comparison.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`n=`](lib.math.numerics.md#n-x-y "Defined at lib/math/numerics.lisp:20:2"): Generalised numeric equality.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`n>`](lib.math.numerics.md#n-x-y "Defined at lib/math/numerics.lisp:18:2"): Generalised numeric greater than.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`n>=`](lib.math.numerics.md#n-x-y "Defined at lib/math/numerics.lisp:19:2"): Generalised numeric greater than or equal to.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`nabs`](lib.math.numerics.md#nabs "Defined at lib/math/numerics.lisp:16:2"): Generalised numeric absolute value.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`nan?`](lib.math.init.md#nan-x "Defined at lib/math/init.lisp:51:2"): Is `X` equal to NaN?|[math](lib.math.init.md "Also exported from prelude")|
| |[`negate`](lib.math.bignum.md#negate-a "Defined at lib/math/bignum.lisp:23:2"): Returns `A` with the sign inverted.|[math/bignum](lib.math.bignum.md)|
| |[`neq?`](lib.core.type.md#neq-x-y "Defined at lib/core/type.lisp:99:2"): Compare `X` and `Y` for inequality deeply.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`new`](lib.math.bignum.md#new-a "Defined at lib/math/bignum.lisp:300:2"): Creates a new bignum from `A`.|[math/bignum](lib.math.bignum.md)|
| |[`new`](lib.luajit.ffi.md#new "Native defined at lib/luajit/ffi.lisp:1:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`nexpt`](lib.math.numerics.md#nexpt "Defined at lib/math/numerics.lisp:8:2"): Generalised numeric exponentiation.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`next`](lib.lua.basic.md#next "Native defined at lib/lua/basic.lisp:29:1")|[lua/basic](lib.lua.basic.md "Also exported from core/prelude, core/table, prelude")|
| |[`nil?`](lib.core.type.md#nil-x "Defined at lib/core/type.lisp:81:2"): Check if `X` does not exist, i.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`ninth`](lib.core.base.md#ninth-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`nkeys`](lib.core.table.md#nkeys-st "Defined at lib/core/table.lisp:113:2"): Return the number of keys in the structure `ST`.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`nmod`](lib.math.numerics.md#nmod "Defined at lib/math/numerics.lisp:7:2"): Generalised numeric modulus.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`nnegate`](lib.math.numerics.md#nnegate "Defined at lib/math/numerics.lisp:14:2"): Generalised numeric negation.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`node->val`](lib.compiler.nodes.md#node-val "Native defined at lib/compiler/nodes.lisp:61:1"): Gets the constant value of `NODE`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`node-contains-var?`](lib.compiler.nodes.md#node-contains-var- "Native defined at lib/compiler/nodes.lisp:67:1"): Determine whether `NODE` contains a reference to the given `VAR`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`node-contains-vars?`](lib.compiler.nodes.md#node-contains-vars- "Native defined at lib/compiler/nodes.lisp:70:1"): Determine whether `NODE` contains a reference to any of the given `VARS`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`none`](lib.core.list.md#none-p-xs "Defined at lib/core/list.lisp:259:2"): Check that no elements in `XS` match the predicate `P`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`norm`](lib.math.vector.md#norm-x "Defined at lib/math/vector.lisp:155:2"): Compute the norm of vector `X` (i.|[math/vector](lib.math.vector.md)|
| |[`not`](lib.core.base.md#not-expr "Defined at lib/core/base.lisp:189:2"): Compute the logical negation of the expression `EXPR`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`nrecip`](lib.math.numerics.md#nrecip "Defined at lib/math/numerics.lisp:13:2"): Generalised numeric reciprocal.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`nsign`](lib.math.numerics.md#nsign "Defined at lib/math/numerics.lisp:15:2"): Generalised numeric sign number.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`nsqrt`](lib.math.numerics.md#nsqrt "Defined at lib/math/numerics.lisp:12:2"): Generalised numeric square root.|[math/numerics](lib.math.numerics.md "Also exported from prelude")|
| |[`nth`](lib.core.list.md#nth-xs-idx "Defined at lib/core/list.lisp:391:2"): Get the `IDX` th element in the list `XS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`nths`](lib.core.list.md#nths-xss-idx "Defined at lib/core/list.lisp:404:2"): Get the IDX-th element in all the lists given at `XSS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`nub`](lib.core.list.md#nub-xs "Defined at lib/core/list.lisp:281:2"): Remove duplicate elements from `XS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`null`](lib.math.vector.md#null-size "Defined at lib/math/vector.lisp:191:2"): Create a vector with a magnitude of 0.|[math/vector](lib.math.vector.md)|
| |[`number->string`](lib.core.prelude.md#number-string "Defined at lib/core/prelude.lisp:48:1"): Convert the number `X` into a string.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`number?`](lib.core.type.md#number-x "Defined at lib/core/type.lisp:32:2"): Check whether `X` is a number.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`numerator`](lib.math.rational.md#numerator-rational "Defined at lib/math/rational.lisp:7:2"): The rational's numerator|[math/rational](lib.math.rational.md "Also exported from prelude")|
| <strong id="sym-o">o</strong> | |
| |[`odd?`](lib.math.init.md#odd-x "Defined at lib/math/init.lisp:39:2"): Is `X` an odd number?|[math](lib.math.init.md "Also exported from prelude")|
| |[`offset`](lib.lua.utf8.md#offset "Native defined at lib/lua/utf8.lisp:6:1")|[lua/utf8](lib.lua.utf8.md)|
| |[`offsetof`](lib.luajit.ffi.md#offsetof "Native defined at lib/luajit/ffi.lisp:20:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`on`](lib.data.lens.md#on-k "Defined at lib/data/lens.lisp:244:2"): `A` lens that focuses on the element of a structure that is at the key `K`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`on!`](lib.data.lens.md#on-k "Defined at lib/data/lens.lisp:262:2"): `A` lens that focuses (**and mutates**) the element of a structure that is at the key `K`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`open`](lib.lua.io.md#open "Native defined at lib/lua/io.lisp:5:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`or`](lib.core.base.md#or-a-b-rest "Macro defined at lib/core/base.lisp:292:2"): Return the logical or of values `A` and `B`, and, if present, the logical or of all the values in `REST`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`os`](lib.luajit.ffi.md#os "Native defined at lib/luajit/ffi.lisp:15:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`output`](lib.lua.io.md#output "Native defined at lib/lua/io.lisp:6:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`over`](lib.data.lens.md#over-l-f-v "Defined at lib/data/lens.lisp:169:2"): Flipped synonym for `^~`|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`overl!`](lib.data.lens.md#overl-lens-f-val "Macro defined at lib/data/lens.lisp:183:2"): Mutate `VAL` by applying to a bit of it the function `F`, using `LENS`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| <strong id="sym-p">p</strong> | |
| |[`pack`](lib.lua.table.md#pack "Native defined at lib/lua/table.lisp:4:1")|[lua/table](lib.lua.table.md)|
| |[`pairs`](lib.lua.basic.md#pairs "Native defined at lib/lua/basic.lisp:30:1")|[lua/basic](lib.lua.basic.md)|
| |[`parse!`](lib.io.argparse.md#parse-spec-args "Defined at lib/io/argparse.lisp:238:2"): Parse `ARGS` using the argument parser defined in `SPEC`.|[io/argparse](lib.io.argparse.md)|
| |[`partition`](lib.core.list.md#partition-p-xs "Defined at lib/core/list.lisp:198:2"): Split `XS` based on the predicate `P`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`path`](lib.lua.package.md#path "Native defined at lib/lua/package.lisp:5:1")|[lua/package](lib.lua.package.md)|
| |[`pattern`](lib.compiler.pattern.md#pattern-ptrn "Macro defined at lib/compiler/pattern.lisp:38:2"): Quote the provided pattern `PTRN`, suitable for matching with i `matches?`.|[compiler/pattern](lib.compiler.pattern.md)|
| |[`pcall`](lib.lua.basic.md#pcall "Native defined at lib/lua/basic.lisp:31:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`pending`](lib.test.init.md#pending-name-body "Macro defined at lib/test/init.lisp:46:2"): Create a test `NAME` whose `BODY` will not be run.|[test](lib.test.init.md)|
| |[`pi`](lib.lua.math.md#pi "Native defined at lib/lua/math.lisp:19:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`polar->`](lib.math.complex.md#polar-magnitude-angle "Defined at lib/math/complex.lisp:122:2"): Create a complex number from the given `MAGNITUDE` and `ANGLE`.|[math/complex](lib.math.complex.md)|
| |[`pop-last!`](lib.core.list.md#pop-last-xs "Defined at lib/core/list.lisp:437:2"): Mutate the list `XS`, removing and returning its last element.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`popen`](lib.lua.io.md#popen "Native defined at lib/lua/io.lisp:7:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`power`](lib.math.bignum.md#power-a-b "Defined at lib/math/bignum.lisp:135:2"): Returns `A` to the power of `B`.|[math/bignum](lib.math.bignum.md)|
| |[`pred`](lib.math.init.md#pred-x "Defined at lib/math/init.lisp:67:2"): Return the predecessor of the number `X`.|[math](lib.math.init.md "Also exported from prelude")|
| |[`preload`](lib.lua.package.md#preload "Native defined at lib/lua/package.lisp:6:1")|[lua/package](lib.lua.package.md)|
| |[`pretty`](lib.core.type.md#pretty "Defined at lib/core/type.lisp:335:2"): Pretty-print a value.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`print`](lib.lua.basic.md#print "Native defined at lib/lua/basic.lisp:32:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base")|
| |[`print!`](lib.core.prelude.md#print- "Defined at lib/core/prelude.lisp:60:1"): Print to standard output.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`printf`](lib.core.prelude.md#printf-fmt-args "Defined at lib/core/prelude.lisp:90:2"): Print the formatted string `FMT` using `ARGS`.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`prod`](lib.core.list.md#prod-xs "Defined at lib/core/list.lisp:648:2"): Return the product of all elements in `XS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`progn`](lib.core.base.md#progn-body "Macro defined at lib/core/base.lisp:149:2"): Group a series of expressions together.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`prune`](lib.core.list.md#prune-xs "Defined at lib/core/list.lisp:344:2"): Remove values matching the predicates `empty?` or `nil?` from the list `XS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`push-cdr!`](lib.core.list.md#push-cdr-xs-vals "Defined at lib/core/list.lisp:418:2"): Mutate the list `XS`, adding `VALS` to its end.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| <strong id="sym-q">q</strong> | |
| |[`quasiquote`](lib.core.base.md#quasiquote-val "Macro defined at lib/core/base.lisp:424:2"): Quote `VAL`, but replacing all `unquote` and `unquote-splice` with their actual value.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`quoted`](lib.core.string.md#quoted "Defined at lib/core/string.lisp:75:1"): Quote the string `STR` so it is suitable for printing.|[core/string](lib.core.string.md "Also exported from core/prelude, prelude")|
| <strong id="sym-r">r</strong> | |
| |[`rad`](lib.lua.math.md#rad "Native defined at lib/lua/math.lisp:20:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`random`](lib.lua.math.md#random "Native defined at lib/lua/math.lisp:21:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`randomseed`](lib.lua.math.md#randomseed "Native defined at lib/lua/math.lisp:22:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`range`](lib.core.list.md#range-args "Defined at lib/core/list.lisp:577:2"): Build a list from :`FROM` to :`TO`, optionally passing by :`BY`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`range/get-source`](lib.compiler.init.md#range-get-source "Native defined at lib/compiler/init.lisp:43:1"): Get the nearest source position of `NODE`|[compiler](lib.compiler.init.md)|
| |[`rational`](lib.math.rational.md#rational "Defined at lib/math/rational.lisp:7:2"): `A` rational number, represented as a tuple of numerator and denominator.|[math/rational](lib.math.rational.md "Also exported from prelude")|
| |[`rational?`](lib.math.rational.md#rational-rational "Defined at lib/math/rational.lisp:7:2")|[math/rational](lib.math.rational.md "Also exported from prelude")|
| |[`rawequal`](lib.lua.basic.md#rawequal "Native defined at lib/lua/basic.lisp:33:1")|[lua/basic](lib.lua.basic.md)|
| |[`rawget`](lib.lua.basic.md#rawget "Native defined at lib/lua/basic.lisp:37:1")|[lua/basic](lib.lua.basic.md)|
| |[`rawlen`](lib.lua.basic.md#rawlen "Native defined at lib/lua/basic.lisp:35:1")|[lua/basic](lib.lua.basic.md)|
| |[`rawset`](lib.lua.basic.md#rawset "Native defined at lib/lua/basic.lisp:38:1")|[lua/basic](lib.lua.basic.md)|
| |[`read`](lib.lua.io.md#read "Native defined at lib/lua/io.lisp:8:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`read-all!`](lib.io.init.md#read-all-path "Defined at lib/io/init.lisp:9:2"): Reads the data from the file at `PATH` and returns it as a string.|[io](lib.io.init.md)|
| |[`read-bytes!`](lib.io.init.md#read-bytes-path "Defined at lib/io/init.lisp:32:2"): Reads the data from the file at `PATH` and returns it as a list of bytes (numbers).|[io](lib.io.init.md)|
| |[`read-lines!`](lib.io.init.md#read-lines-path "Defined at lib/io/init.lisp:20:2"): Reads the lines from the file at `PATH` and returns it as a list of strings.|[io](lib.io.init.md)|
| |[`real`](lib.math.complex.md#real-complex "Defined at lib/math/complex.lisp:16:2"): The real part of this `complex` number.|[math/complex](lib.math.complex.md)|
| |[`reduce`](lib.core.list.md#reduce-f-z-xs "Defined at lib/core/list.lisp:103:2"): Accumulate the list `XS` using the binary function `F` and the zero element `Z`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`reduced-echelon`](lib.math.matrix.md#reduced-echelon-matrix "Defined at lib/math/matrix.lisp:179:2"): Reduce the given `MATRIX` to reduced row echelon form.|[math/matrix](lib.math.matrix.md)|
| |[`reify`](lib.compiler.resolve.md#reify-x "Defined at lib/compiler/resolve.lisp:49:2"): Return the definition of the _symbol_ (not variable) `X`, returning `nil` if it's not a top-level definition.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`remove`](lib.lua.os.md#remove "Native defined at lib/lua/os.lisp:7:1")|[lua/os](lib.lua.os.md)|
| |[`remove`](lib.lua.table.md#remove "Native defined at lib/lua/table.lisp:5:1")|[lua/table](lib.lua.table.md)|
| |[`remove-nth!`](lib.core.list.md#remove-nth-li-idx "Defined at lib/core/list.lisp:454:2"): Mutate the list `LI`, removing the value at `IDX` and returning it.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`rename`](lib.lua.os.md#rename "Native defined at lib/lua/os.lisp:8:1")|[lua/os](lib.lua.os.md)|
| |[`rep`](lib.lua.string.md#rep "Native defined at lib/lua/string.lisp:10:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| |[`require`](lib.lua.basic.md#require "Native defined at lib/lua/basic.lisp:39:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`reset`](lib.control.prompt.md#reset-body "Macro defined at lib/control/prompt.lisp:131:2"): Establish a prompt, and evaluate `BODY` within that prompt.|[control/prompt](lib.control.prompt.md)|
| |[`resume`](lib.lua.coroutine.md#resume "Native defined at lib/lua/coroutine.lisp:3:1")|[lua/coroutine](lib.lua.coroutine.md)|
| |[`reverse`](lib.core.list.md#reverse-xs "Defined at lib/core/list.lisp:606:2"): Reverse the list `XS`, using the accumulator `ACC`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`reverse`](lib.lua.string.md#reverse "Native defined at lib/lua/string.lisp:11:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| |[`round`](lib.math.init.md#round-x "Defined at lib/math/init.lisp:96:2"): Round `X`, to the nearest integer.|[math](lib.math.init.md "Also exported from prelude")|
| |[`running`](lib.lua.coroutine.md#running "Native defined at lib/lua/coroutine.lisp:4:1")|[lua/coroutine](lib.lua.coroutine.md)|
| <strong id="sym-s">s</strong> | |
| |[`scope-vars`](lib.compiler.resolve.md#scope-vars "Native defined at lib/compiler/resolve.lisp:10:1"): Return the variables present in the given `SCOPE`, using the `active-scope` if none is given.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`searchers`](lib.lua.package.md#searchers "Native defined at lib/lua/package.lisp:7:1")|[lua/package](lib.lua.package.md)|
| |[`searchpath`](lib.lua.package.md#searchpath "Native defined at lib/lua/package.lisp:8:1")|[lua/package](lib.lua.package.md)|
| |[`second`](lib.core.base.md#second-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`section`](lib.test.init.md#section-name-body "Macro defined at lib/test/init.lisp:55:2"): Create a group of tests defined in `BODY` whose names take the form `<prefix> NAME <test_name>`|[test](lib.test.init.md)|
| |[`select`](lib.lua.basic.md#select "Native defined at lib/lua/basic.lisp:40:1")|[lua/basic](lib.lua.basic.md)|
| |[`self`](lib.data.function.md#self-x-key-args "Defined at lib/data/function.lisp:169:2"): Index `X` with `KEY` and invoke the resulting function with `X` and `ARGS`.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`set`](lib.data.lens.md#set-l-n-v "Defined at lib/data/lens.lisp:173:2"): Flipped synonym for `^=`|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`set->list`](lib.data.set.md#set-list-set "Defined at lib/data/set.lisp:133:2"): Convert `SET` to a list.|[data/set](lib.data.set.md)|
| |[`set-action`](lib.io.argparse.md#set-action-arg-data-value "Defined at lib/io/argparse.lisp:37:2"): Set the appropriate key in `DATA` for `ARG` to `VALUE`.|[io/argparse](lib.io.argparse.md)|
| |[`set-idx!`](lib.lua.basic.md#set-idx- "Native defined at lib/lua/basic.lisp:36:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base")|
| |[`set-num-action`](lib.io.argparse.md#set-num-action-aspec-data-value-usage- "Defined at lib/io/argparse.lisp:50:2"): Set the appropriate key in `DATA` for `ARG` to `VALUE`, ensuring it is a number.|[io/argparse](lib.io.argparse.md)|
| |[`set-of`](lib.data.set.md#set-of-values "Defined at lib/data/set.lisp:121:2"): Create the set containing `VALUES` with the default hash function.|[data/set](lib.data.set.md)|
| |[`set?`](lib.data.set.md#set-set "Defined at lib/data/set.lisp:6:2")|[data/set](lib.data.set.md)|
| |[`sethook`](lib.lua.debug.md#sethook "Native defined at lib/lua/debug.lisp:9:1")|[lua/debug](lib.lua.debug.md)|
| |[`setl!`](lib.data.lens.md#setl-lens-new-val "Macro defined at lib/data/lens.lisp:177:2"): Mutate `VAL` by replacing a bit of it with `NEW`, using `LENS`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`setlocal`](lib.lua.debug.md#setlocal "Native defined at lib/lua/debug.lisp:10:1")|[lua/debug](lib.lua.debug.md)|
| |[`setlocale`](lib.lua.os.md#setlocale "Native defined at lib/lua/os.lisp:9:1")|[lua/os](lib.lua.os.md)|
| |[`setmetatable`](lib.lua.basic.md#setmetatable "Native defined at lib/lua/basic.lisp:41:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`setmetatable`](lib.lua.debug.md#setmetatable "Native defined at lib/lua/debug.lisp:11:1")|[lua/debug](lib.lua.debug.md)|
| |[`setter`](lib.data.lens.md#setter-over "Defined at lib/data/lens.lisp:95:2"): Define a setting lens using `VIEW` as the accessor.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`setter?`](lib.data.lens.md#setter-lens "Defined at lib/data/lens.lisp:117:2"): Check that `LENS` has a defined setter, along with being tagged as a `LENS`.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`setupvalue`](lib.lua.debug.md#setupvalue "Native defined at lib/lua/debug.lisp:12:1")|[lua/debug](lib.lua.debug.md)|
| |[`setuservalue`](lib.lua.debug.md#setuservalue "Native defined at lib/lua/debug.lisp:13:1")|[lua/debug](lib.lua.debug.md)|
| |[`seventh`](lib.core.base.md#seventh-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`shift`](lib.control.prompt.md#shift-k-body "Macro defined at lib/control/prompt.lisp:146:2"): Abort to the nearest `reset`, and evaluate `BODY` in a scope where the captured continuation is bound to `K`.|[control/prompt](lib.control.prompt.md)|
| |[`shl`](lib.lua.bit32.md#shl "Native defined at lib/lua/bit32.lisp:27:1"): Returns `X` shifted left by `DISP`.|[lua/bit32](lib.lua.bit32.md)|
| |[`shl`](lib.math.bignum.md#shl-a-b "Defined at lib/math/bignum.lisp:164:2"): Returns `A` shifted left by `B`.|[math/bignum](lib.math.bignum.md)|
| |[`shl!`](lib.math.bignum.md#shl-a-b "Defined at lib/math/bignum.lisp:152:2"): Shifts (modifies) `A` to the left by `B`.|[math/bignum](lib.math.bignum.md)|
| |[`shr`](lib.lua.bit32.md#shr "Native defined at lib/lua/bit32.lisp:31:1"): Returns `X` shifted right by `DISP`.|[lua/bit32](lib.lua.bit32.md)|
| |[`shr`](lib.math.bignum.md#shr-a-b "Defined at lib/math/bignum.lisp:181:2"): Returns `A` shifted right by `B`.|[math/bignum](lib.math.bignum.md)|
| |[`shr!`](lib.math.bignum.md#shr-a-b "Defined at lib/math/bignum.lisp:170:2"): Shifts (modifies) `A` to the right by `B`.|[math/bignum](lib.math.bignum.md)|
| |[`sin`](lib.lua.math.md#sin "Native defined at lib/lua/math.lisp:23:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`sixth`](lib.core.base.md#sixth-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`sizeof`](lib.luajit.ffi.md#sizeof "Native defined at lib/luajit/ffi.lisp:4:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`slice`](lib.core.base.md#slice-xs-start-finish "Defined at lib/core/base.lisp:22:1"): Take a slice of `XS`, with all values at indexes between `START` and `FINISH` (or the last entry of `XS` if not specified).|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`slot?`](lib.data.function.md#slot-symb "Defined at lib/data/function.lisp:3:2"): Test whether `SYMB` is a slot.|[data/function](lib.data.function.md "Also exported from prelude")|
| |[`snoc`](lib.core.list.md#snoc-xss-xs "Defined at lib/core/list.lisp:81:2"): Return a copy of the list `XS` with the element `XS` added to its end.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`sort`](lib.lua.table.md#sort "Native defined at lib/lua/table.lisp:6:1")|[lua/table](lib.lua.table.md)|
| |[`sort`](lib.core.list.md#sort-xs-f "Defined at lib/core/list.lisp:723:2"): Sort the list `XS`, non-destructively, optionally using `F` as a comparator.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`sort!`](lib.core.list.md#sort-xs-f "Defined at lib/core/list.lisp:741:2"): Sort the list `XS` in place, optionally using `F` as a comparator.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`split`](lib.core.list.md#split-xs-y "Defined at lib/core/list.lisp:686:2"): Splits a list into sub-lists by the separator `Y`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`split`](lib.core.string.md#split-text-pattern-limit "Defined at lib/core/string.lisp:20:2"): Split the string given by `TEXT` in at most `LIMIT` components, which are delineated by the Lua pattern `PATTERN`.|[core/string](lib.core.string.md "Also exported from core/prelude, prelude")|
| |[`sprintf`](lib.core.prelude.md#sprintf-fmt-args "Defined at lib/core/prelude.lisp:80:2"): Format the format string `FMT` using `ARGS`.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`sqrt`](lib.lua.math.md#sqrt "Native defined at lib/lua/math.lisp:24:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`starts-with?`](lib.core.string.md#starts-with-str-prefix "Defined at lib/core/string.lisp:94:2"): Determine whether `STR` starts with `PREFIX`.|[core/string](lib.core.string.md "Also exported from core/prelude, prelude")|
| |[`status`](lib.lua.coroutine.md#status "Native defined at lib/lua/coroutine.lisp:5:1")|[lua/coroutine](lib.lua.coroutine.md)|
| |[`stderr`](lib.lua.io.md#stderr "Native defined at lib/lua/io.lisp:9:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`stdin`](lib.lua.io.md#stdin "Native defined at lib/lua/io.lisp:10:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`stdout`](lib.lua.io.md#stdout "Native defined at lib/lua/io.lisp:11:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`string`](lib.luajit.ffi.md#string "Native defined at lib/luajit/ffi.lisp:16:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`string->number`](lib.core.prelude.md#string-number "Defined at lib/core/prelude.lisp:34:1"): Convert the string `X` into a number.|[core/prelude](lib.core.prelude.md "Also exported from prelude")|
| |[`string->symbol`](lib.core.symbol.md#string-symbol-x "Defined at lib/core/symbol.lisp:12:2"): Convert the string `X` to a symbol.|[core/symbol](lib.core.symbol.md "Also exported from core/prelude, prelude")|
| |[`string?`](lib.core.type.md#string-x "Defined at lib/core/type.lisp:26:2"): Check whether `X` is a string.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`strongly-connected-components`](lib.data.graph.md#strongly-connected-components-graph "Defined at lib/data/graph.lisp:78:2"): Find all strong components from a `GRAPH`.|[data/graph](lib.data.graph.md)|
| |[`struct`](lib.core.table.md#struct-entries "Defined at lib/core/table.lisp:62:2"): Return the structure given by the list of pairs `ENTRIES`.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`struct->assoc`](lib.data.alist.md#struct-assoc-tbl "Defined at lib/data/alist.lisp:92:2"): Convert the structure `TBL` into an association list.|[data/alist](lib.data.alist.md "Also exported from prelude")|
| |[`struct->list`](lib.core.table.md#struct-list-tbl "Defined at lib/core/table.lisp:7:2"): Converts a structure `TBL` that is a list by having its keys be indices to a regular list.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`struct->list!`](lib.core.table.md#struct-list-tbl "Defined at lib/core/table.lisp:19:2"): Converts a structure `TBL` that is a list by having its keys be indices to a regular list.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`sub`](lib.lua.string.md#sub "Native defined at lib/lua/string.lisp:12:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| |[`subtract`](lib.math.bignum.md#subtract-a-b "Defined at lib/math/bignum.lisp:58:2"): Returns `A` minus `B`.|[math/bignum](lib.math.bignum.md)|
| |[`succ`](lib.math.init.md#succ-x "Defined at lib/math/init.lisp:63:2"): Return the successor of the number `X`.|[math](lib.math.init.md "Also exported from prelude")|
| |[`sum`](lib.core.list.md#sum-xs "Defined at lib/core/list.lisp:638:2"): Return the sum of all elements in `XS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`sym..`](lib.core.symbol.md#sym-xs "Defined at lib/core/symbol.lisp:16:2"): Concatenate all the symbols in `XS`.|[core/symbol](lib.core.symbol.md "Also exported from core/prelude, prelude")|
| |[`symbol->string`](lib.core.symbol.md#symbol-string-x "Defined at lib/core/symbol.lisp:6:2"): Convert the symbol `X` to a string.|[core/symbol](lib.core.symbol.md "Also exported from core/prelude, prelude")|
| |[`symbol->var`](lib.compiler.nodes.md#symbol-var "Native defined at lib/compiler/nodes.lisp:28:1"): Extract the variable from the given `SYMBOL`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`symbol?`](lib.core.type.md#symbol-x "Defined at lib/core/type.lisp:38:2"): Check whether `X` is a symbol.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| <strong id="sym-t">t</strong> | |
| |[`table?`](lib.core.type.md#table-x "Defined at lib/core/type.lisp:9:2"): Check whether the value `X` is a table.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`tail`](lib.data.lens.md#tail "Defined at lib/data/lens.lisp:212:1"): `A` lens equivalent to `cdr`, which `view`s and applies `over` to all but the first element of a list.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`take`](lib.core.list.md#take-xs-n "Defined at lib/core/list.lisp:61:2"): Take the first `N` elements of the list `XS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`take-while`](lib.core.list.md#take-while-p-xs-idx "Defined at lib/core/list.lisp:658:2"): Takes elements from the list `XS` while the predicate `P` is true, starting at index `IDX`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`tan`](lib.lua.math.md#tan "Native defined at lib/lua/math.lisp:25:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`tenth`](lib.core.base.md#tenth-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`third`](lib.core.base.md#third-rest "Defined at lib/core/base.lisp:470:1")|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`time`](lib.lua.os.md#time "Native defined at lib/lua/os.lisp:10:1")|[lua/os](lib.lua.os.md)|
| |[`tmpfile`](lib.lua.io.md#tmpfile "Native defined at lib/lua/io.lisp:12:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`tmpname`](lib.lua.os.md#tmpname "Native defined at lib/lua/os.lisp:11:1")|[lua/os](lib.lua.os.md)|
| |[`tointeger`](lib.lua.math.md#tointeger "Native defined at lib/lua/math.lisp:26:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`tonumber`](lib.lua.basic.md#tonumber "Native defined at lib/lua/basic.lisp:42:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`tostring`](lib.math.bignum.md#tostring-a-format "Defined at lib/math/bignum.lisp:202:2"): Converts the bignum `A` to a string.|[math/bignum](lib.math.bignum.md)|
| |[`tostring`](lib.lua.basic.md#tostring "Native defined at lib/lua/basic.lisp:43:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| |[`traceback`](lib.lua.debug.md#traceback "Native defined at lib/lua/debug.lisp:14:1")|[lua/debug](lib.lua.debug.md)|
| |[`traverse`](lib.core.list.md#traverse-xs-f "Defined at lib/core/list.lisp:356:2"): An alias for `map` with the arguments `XS` and `F` flipped.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`traverse-node`](lib.compiler.nodes.md#traverse-node "Native defined at lib/compiler/nodes.lisp:16:1"): Traverse `NODE` with `VISITOR`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`traverse-nodes`](lib.compiler.nodes.md#traverse-nodes "Native defined at lib/compiler/nodes.lisp:23:1"): Traverse a list of `NODES`, starting at `IDX`, using the specified `VISITOR`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`traverse-postorder`](lib.data.graph.md#traverse-postorder-root-visitor "Defined at lib/data/graph.lisp:217:2"): Visit a graph using postorder traversal starting at `ROOT`, calling `VISITOR` for each vertex.|[data/graph](lib.data.graph.md)|
| |[`traverse-preorder`](lib.data.graph.md#traverse-preorder-root-visitor "Defined at lib/data/graph.lisp:180:2"): Visit a graph using preorder traversal starting at `ROOT`, calling `VISITOR` for each vertex.|[data/graph](lib.data.graph.md)|
| |[`traversing`](lib.data.lens.md#traversing-l "Defined at lib/data/lens.lisp:281:2"): `A` lens which maps the lens `L` over every element of a given list.|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`trim`](lib.core.string.md#trim-str "Defined at lib/core/string.lisp:64:2"): Remove whitespace from both sides of `STR`.|[core/string](lib.core.string.md "Also exported from core/prelude, prelude")|
| |[`tripping`](lib.test.check.md#tripping-f-g-x "Macro defined at lib/test/check.lisp:122:2"): Express that the composition of the functions `F` and `G` (in order!|[test/check](lib.test.check.md "Also exported from test")|
| |[`try-var-lookup`](lib.compiler.resolve.md#try-var-lookup "Native defined at lib/compiler/resolve.lisp:22:1"): Try to look up `SYMBOL` in the given `SCOPE`, using the `active-scope` if none given.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`type`](lib.lua.io.md#type "Native defined at lib/lua/io.lisp:13:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`type`](lib.core.type.md#type-val "Defined at lib/core/type.lisp:91:2"): Return the type of `VAL`.|[core/type](lib.core.type.md "Also exported from core/prelude, prelude")|
| |[`type`](lib.lua.math.md#type "Native defined at lib/lua/math.lisp:27:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`type#`](lib.lua.basic.md#type- "Native defined at lib/lua/basic.lisp:44:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base")|
| |[`typeinfo`](lib.luajit.ffi.md#typeinfo "Native defined at lib/luajit/ffi.lisp:13:1")|[luajit/ffi](lib.luajit.ffi.md)|
| |[`typeof`](lib.luajit.ffi.md#typeof "Native defined at lib/luajit/ffi.lisp:3:1")|[luajit/ffi](lib.luajit.ffi.md)|
| <strong id="sym-u">u</strong> | |
| |[`ult`](lib.lua.math.md#ult "Native defined at lib/lua/math.lisp:28:1")|[lua/math](lib.lua.math.md "Also exported from core/prelude, prelude")|
| |[`union`](lib.data.set.md#union-a-b "Defined at lib/data/set.lisp:84:2"): The set of values that occur in either `A` or `B`.|[data/set](lib.data.set.md)|
| |[`union`](lib.core.list.md#union-xs-ys "Defined at lib/core/list.lisp:300:2"): Set-like union of `XS` and `YS`.|[core/list](lib.core.list.md "Also exported from core/prelude, prelude")|
| |[`unit`](lib.math.vector.md#unit-x "Defined at lib/math/vector.lisp:176:2"): Convert the vector `X` into the unit vector.|[math/vector](lib.math.vector.md)|
| |[`unless`](lib.core.base.md#unless-c-body "Macro defined at lib/core/base.lisp:176:2"): Evaluate `BODY` if `C` is false, otherwise, evaluate `nil`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`unpack`](lib.lua.table.md#unpack "Native defined at lib/lua/table.lisp:7:1")|[lua/table](lib.lua.table.md "Also exported from core/base, core/prelude, prelude")|
| |[`update-struct`](lib.core.table.md#update-struct-st-keys "Defined at lib/core/table.lisp:149:2"): Create a new structure based of `ST`, setting the values given by the pairs in `KEYS`.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`upper`](lib.lua.string.md#upper "Native defined at lib/lua/string.lisp:13:1")|[lua/string](lib.lua.string.md "Also exported from core/prelude, core/string, prelude")|
| |[`upvalueid`](lib.lua.debug.md#upvalueid "Native defined at lib/lua/debug.lisp:15:1")|[lua/debug](lib.lua.debug.md)|
| |[`upvaluejoin`](lib.lua.debug.md#upvaluejoin "Native defined at lib/lua/debug.lisp:16:1")|[lua/debug](lib.lua.debug.md)|
| |[`usage!`](lib.io.argparse.md#usage-spec-name "Defined at lib/io/argparse.lisp:167:2"): Display a short usage for the argument parser as defined in `SPEC`.|[io/argparse](lib.io.argparse.md)|
| |[`usage-error!`](lib.io.argparse.md#usage-error-spec-name-error "Defined at lib/io/argparse.lisp:181:2"): Display the usage of `SPEC` and exit with an `ERROR` message.|[io/argparse](lib.io.argparse.md)|
| |[`use`](lib.core.binders.md#use-var-body "Macro defined at lib/core/binders.lisp:201:2"): Bind each variable in `VAR`, checking for truthyness between bindings, execute `BODY`, then run a finaliser for all the variables bound by `VAR`.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| <strong id="sym-v">v</strong> | |
| |[`val->node`](lib.compiler.nodes.md#val-node "Native defined at lib/compiler/nodes.lisp:64:1"): Gets the node representation of the constant `VALUE`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`values`](lib.core.table.md#values-st "Defined at lib/core/table.lisp:143:2"): Return the values in the structure `ST`.|[core/table](lib.core.table.md "Also exported from core/prelude, prelude")|
| |[`values-list`](lib.core.base.md#values-list-xs "Macro defined at lib/core/base.lisp:452:2"): Return multiple values, one per element in `XS`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`var->symbol`](lib.compiler.nodes.md#var-symbol "Native defined at lib/compiler/nodes.lisp:35:1"): Create a new symbol referencing the given `VARIABLE`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`var-definition`](lib.compiler.resolve.md#var-definition "Native defined at lib/compiler/resolve.lisp:29:1"): Get the definition of the given `VARIABLE`, returning `nil` if it is not a top level definition.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`var-docstring`](lib.compiler.resolve.md#var-docstring "Native defined at lib/compiler/resolve.lisp:45:1"): Get the docstring for the given `VARIABLE`, returning `nil` if it is not a top level definition.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`var-lookup`](lib.compiler.resolve.md#var-lookup "Native defined at lib/compiler/resolve.lisp:14:1"): Look up `SYMBOL` in the given `SCOPE`, using the `active-scope` if none given.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`var-usage`](lib.compiler.pass.md#var-usage "Native defined at lib/compiler/pass.lisp:76:1"): Get usage information about the specified `VAR`.|[compiler/pass](lib.compiler.pass.md)|
| |[`var-value`](lib.compiler.resolve.md#var-value "Native defined at lib/compiler/resolve.lisp:37:1"): Get the value of the given `VARIABLE`, returning `nil` if it is not a top level definition.|[compiler/resolve](lib.compiler.resolve.md)|
| |[`vector`](lib.math.vector.md#vector-items "Defined at lib/math/vector.lisp:17:2"): Create a new vector from several values.|[math/vector](lib.math.vector.md)|
| |[`vector-dim`](lib.math.vector.md#vector-dim-vector "Defined at lib/math/vector.lisp:7:2"): The dimension of this vector.|[math/vector](lib.math.vector.md)|
| |[`vector-item`](lib.math.vector.md#vector-item-vector-i "Defined at lib/math/vector.lisp:53:2"): Get the `I` th element in the `VECTOR`.|[math/vector](lib.math.vector.md)|
| |[`vector?`](lib.math.vector.md#vector-vector "Defined at lib/math/vector.lisp:7:2")|[math/vector](lib.math.vector.md)|
| |[`vertex?`](lib.data.graph.md#vertex-vertex "Defined at lib/data/graph.lisp:17:2")|[data/graph](lib.data.graph.md)|
| |[`view`](lib.data.lens.md#view-l-v "Defined at lib/data/lens.lisp:165:2"): Flipped synonym for `^.`|[data/lens](lib.data.lens.md "Also exported from prelude")|
| |[`visit-node`](lib.compiler.nodes.md#visit-node "Native defined at lib/compiler/nodes.lisp:4:1"): Visit `NODE` with `VISITOR`.|[compiler/nodes](lib.compiler.nodes.md)|
| |[`visit-nodes`](lib.compiler.nodes.md#visit-nodes "Native defined at lib/compiler/nodes.lisp:11:1"): Visit a list of `NODES`, starting at `IDX`, using the specified `VISITOR`.|[compiler/nodes](lib.compiler.nodes.md)|
| <strong id="sym-w">w</strong> | |
| |[`when`](lib.core.base.md#when-c-body "Macro defined at lib/core/base.lisp:172:2"): Evaluate `BODY` when `C` is true, otherwise, evaluate `nil`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`when-let`](lib.core.binders.md#when-let-vars-body "Macro defined at lib/core/binders.lisp:71:2"): Bind `VARS`, as with `let`, and check they are all truthy before evaluating `BODY`.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`when-let*`](lib.core.binders.md#when-let-vars-body "Macro defined at lib/core/binders.lisp:93:2"): Bind each pair of `(name value)` of `VARS`, checking if the value is truthy before binding the next, and finally evaluating `BODY`.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`when-with`](lib.core.binders.md#when-with-var-body "Macro defined at lib/core/binders.lisp:118:2"): Bind the `PAIR` var of the form `(name value)`, only evaluating `BODY` if the value is truthy|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`while`](lib.core.base.md#while-check-body "Macro defined at lib/core/base.lisp:251:2"): Iterate `BODY` while the expression `CHECK` evaluates to `true`.|[core/base](lib.core.base.md "Also exported from core/prelude, prelude")|
| |[`width`](lib.math.matrix.md#width-matrix "Defined at lib/math/matrix.lisp:6:2"): The width of this matrix.|[math/matrix](lib.math.matrix.md)|
| |[`will`](lib.test.init.md#will-name-body "Macro defined at lib/test/init.lisp:65:2"): Create a test whose `BODY` asserts `NAME` will happen|[test](lib.test.init.md)|
| |[`will-not`](lib.test.init.md#will-not-name-body "Macro defined at lib/test/init.lisp:69:2"): Create a test whose `BODY` asserts `NAME` will not happen|[test](lib.test.init.md)|
| |[`with`](lib.core.base.md#with-var-body "Macro defined at lib/core/base.lisp:270:2"): Bind the single variable `VAR`, then evaluate `BODY`.|[core/base](lib.core.base.md)|
| |[`with`](lib.core.binders.md#with-var-body "Macro defined at lib/core/binders.lisp:51:2"): Bind the single variable `VAR`, then evaluate `BODY`.|[core/binders](lib.core.binders.md "Also exported from core/prelude, prelude")|
| |[`wrap`](lib.lua.coroutine.md#wrap "Native defined at lib/lua/coroutine.lisp:6:1")|[lua/coroutine](lib.lua.coroutine.md)|
| |[`write`](lib.lua.io.md#write "Native defined at lib/lua/io.lisp:14:1")|[lua/io](lib.lua.io.md "Also exported from core/prelude, prelude")|
| |[`write-all!`](lib.io.init.md#write-all-path-data "Defined at lib/io/init.lisp:59:2"): Writes the string `DATA` to the file at `PATH`.|[io](lib.io.init.md)|
| |[`write-bytes!`](lib.io.init.md#write-bytes-path-data "Defined at lib/io/init.lisp:85:2"): Writes the bytes (list of numbers) `DATA` to the file at `PATH`.|[io](lib.io.init.md)|
| |[`write-lines!`](lib.io.init.md#write-lines-path-data "Defined at lib/io/init.lisp:72:2"): Writes the lines (list of strings) `DATA` to the file at `PATH`.|[io](lib.io.init.md)|
| <strong id="sym-x">x</strong> | |
| |[`xpcall`](lib.lua.basic.md#xpcall "Native defined at lib/lua/basic.lisp:45:1")|[lua/basic](lib.lua.basic.md "Also exported from core/base, core/prelude, prelude")|
| <strong id="sym-y">y</strong> | |
| |[`yield`](lib.lua.coroutine.md#yield "Native defined at lib/lua/coroutine.lisp:7:1")|[lua/coroutine](lib.lua.coroutine.md)|
